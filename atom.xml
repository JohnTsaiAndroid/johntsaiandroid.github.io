<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JohnTsai</title>
  <subtitle>万物之中，希望最美，最美之物，永不凋零.</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://johntsai.work/"/>
  <updated>2017-03-16T03:22:37.000Z</updated>
  <id>http://johntsai.work/</id>
  
  <author>
    <name>John Tsai</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CSS学习笔记</title>
    <link href="http://johntsai.work/2017/03/15/CSS_Learn_Notes_1/"/>
    <id>http://johntsai.work/2017/03/15/CSS_Learn_Notes_1/</id>
    <published>2017-03-15T06:33:03.000Z</published>
    <updated>2017-03-16T03:22:37.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="u4EC0_u4E48_u662FCSS"><a href="#u4EC0_u4E48_u662FCSS" class="headerlink" title="什么是CSS"></a>什么是CSS</h3><p>CSS指层叠样式表(<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)</p>
<h3 id="u5982_u4F55_u521B_u5EFACSS"><a href="#u5982_u4F55_u521B_u5EFACSS" class="headerlink" title="如何创建CSS"></a>如何创建CSS</h3><h4 id="u5982_u4F55_u63D2_u5165_u6837_u5F0F_u8868"><a href="#u5982_u4F55_u63D2_u5165_u6837_u5F0F_u8868" class="headerlink" title="如何插入样式表"></a>如何插入样式表</h4><ul>
<li>外部样式表</li>
<li>内部样式表</li>
<li><p>内联样式</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> &lt;!--外部样式表--&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;link rel="stylesheet" type="text/css" href="mystyle.css" /&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--内部样式表--&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">  &lt;style type="text/css"&gt;</span><br><span class="line">  hr&#123;</span><br><span class="line">    color:sienna;</span><br><span class="line">  &#125;</span><br><span class="line">  p&#123;</span><br><span class="line">    margin-left:20px;</span><br><span class="line">  &#125;</span><br><span class="line">  &lt;/style&gt;</span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;!--内联样式--&gt;</span><br><span class="line">  &lt;p style="color:sienna; margin-left:20px"&gt;</span><br><span class="line">    这是一个段落</span><br><span class="line">  &lt;/p&gt;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="u591A_u4E2A_u6837_u5F0F_u5B9A_u4E49_u7684_u4F18_u5148_u7EA7"><a href="#u591A_u4E2A_u6837_u5F0F_u5B9A_u4E49_u7684_u4F18_u5148_u7EA7" class="headerlink" title="多个样式定义的优先级"></a>多个样式定义的优先级</h3><ul>
<li>1.内联样式（在HTML元素内部，优先级最高）</li>
<li>2.内部样式表（位于<head>标签内部）</head></li>
<li>3.外部样式表</li>
<li>4.浏览器缺省设置</li>
</ul>
<h3 id="CSS_u8BED_u6CD5"><a href="#CSS_u8BED_u6CD5" class="headerlink" title="CSS语法"></a>CSS语法</h3><p>选择器+声明</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">selector&#123;</span><br><span class="line">   declaration1;</span><br><span class="line">   declaration2;</span><br><span class="line">   ...</span><br><span class="line">   declarationN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>声明=属性+值</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">selector</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">property</span>:<span class="value">value</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>多个声明用分号<code>(;)</code>分隔，最后一个声明的分号可以省略，但一般不省略。</p>
<h3 id="u9009_u62E9_u5668_u7684_u5206_u7EC4"><a href="#u9009_u62E9_u5668_u7684_u5206_u7EC4" class="headerlink" title="选择器的分组"></a>选择器的分组</h3><p>多个选择器可以分享相同的声明</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span>,<span class="tag">h2</span>,<span class="tag">h3</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value">green</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="u6D3E_u751F_u9009_u62E9_u5668"><a href="#u6D3E_u751F_u9009_u62E9_u5668" class="headerlink" title="派生选择器"></a>派生选择器</h3><p>通过依据元素在其位置的上下文关系来定义样式，这种方式在CSS1中叫上下文选择器，在CSS2中叫派生选择器。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">li</span> <span class="tag">strong</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">font-style</span>:<span class="value">italic</span></span>;</span><br><span class="line">   <span class="rule"><span class="attribute">font-weight</span>:<span class="value">normal</span></span>; </span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="id_u9009_u62E9_u5668"><a href="#id_u9009_u62E9_u5668" class="headerlink" title="id选择器"></a>id选择器</h3><p>为标有特定id的HTML元素指定特定的样式，用<code>#</code>来定义。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#red</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value">red</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="id">#green</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value">green</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"red"</span>&gt;</span>红段落<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span> <span class="attribute">id</span>=<span class="value">"green"</span>&gt;</span>绿段落<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="id_u9009_u62E9_u5668_u548C_u6D3E_u751F_u9009_u62E9_u5668"><a href="#id_u9009_u62E9_u5668_u548C_u6D3E_u751F_u9009_u62E9_u5668" class="headerlink" title="id选择器和派生选择器"></a>id选择器和派生选择器</h3><p>id选择器常常用于建立派生选择器。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="id">#sidebar</span> <span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">font-style</span>:<span class="value">italic</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">text-align</span>:<span class="value">center</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">margin-top</span>:<span class="value"><span class="number">0.5em</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="CSS_u7C7B_u9009_u62E9_u5668"><a href="#CSS_u7C7B_u9009_u62E9_u5668" class="headerlink" title="CSS类选择器"></a>CSS类选择器</h3><p>类选择器以一个点号显示:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.center</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">text-align</span>:<span class="value">center</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">h1</span> <span class="attribute">class</span>=<span class="value">"center"</span>&gt;</span></span><br><span class="line"> 居中显示</span><br><span class="line"><span class="tag">&lt;/<span class="title">h1</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="title">p</span> <span class="attribute">class</span>=<span class="value">"center"</span>&gt;</span></span><br><span class="line"> 也是居中显示</span><br><span class="line"><span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>也可用作派生选择器</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.fancy</span> <span class="tag">td</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#f60</span></span></span>;</span><br><span class="line">   <span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#666</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>元素也可基于它们的类而被选择:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">td</span><span class="class">.fancy</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">color</span>:<span class="value"><span class="hexcolor">#f60</span></span></span>;</span><br><span class="line">   <span class="rule"><span class="attribute">background</span>:<span class="value"><span class="hexcolor">#666</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="CSS_u5C5E_u6027_u9009_u62E9_u5668"><a href="#CSS_u5C5E_u6027_u9009_u62E9_u5668" class="headerlink" title="CSS属性选择器"></a>CSS属性选择器</h3><p>对带有指定属性的HTML元素设置样式。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr_selector">[title]</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value">red</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloud.githubusercontent.com/assets/8317477/23936482/5fcdef0e-098d-11e7-8d98-5a1e7ff37e96.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;u4EC0_u4E48_u662FCSS&quot;&gt;&lt;a href=&quot;#u4EC0_u4E48_u662FCSS&quot; class=&quot;headerlink&quot; title=&quot;什么是CSS&quot;&gt;&lt;/a&gt;什么是CSS&lt;/h3&gt;&lt;p&gt;CSS指层叠样式表(&lt;strong&gt;C&lt;/stron
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://johntsai.work/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>CSS学习笔记（二）——样式</title>
    <link href="http://johntsai.work/2017/03/15/CSS_Learn_Notes_2/"/>
    <id>http://johntsai.work/2017/03/15/CSS_Learn_Notes_2/</id>
    <published>2017-03-15T06:33:03.000Z</published>
    <updated>2017-03-16T06:25:15.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CSS__u80CC_u666F"><a href="#CSS__u80CC_u666F" class="headerlink" title="CSS 背景"></a>CSS 背景</h3><ul>
<li>背景色</li>
</ul>
<p><code>background-color</code>为元素设置背景色</p>
<p>如</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value">gray</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>背景图像<br><code>background-image</code>,默认值为<code>none</code></li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background-image</span>:<span class="value"><span class="function">url</span>(https://ss0.bdstatic.com/<span class="number">5</span>aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png)</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>背景重复</li>
</ul>
<p><code>background-repeat</code>设置，可选的值有<code>repeat-x</code>,<code>repeat-y</code>, <code>repeat</code>,<code>no-repeat</code></p>
<ul>
<li>背景定位</li>
</ul>
<p><code>background-position</code>设置图像的位置。</p>
<blockquote>
<p>可选的值有<code>center</code>,<code>top</code>,<code>bottom</code>,<code>left</code>,<code>right</code>或者是长度值<code>5px</code>,<code>10cm</code>以及百分值<code>50%</code></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">background-image</span>:<span class="value"><span class="function">url</span>(https://ss0.bdstatic.com/<span class="number">5</span>aV1bjqh_Q23odCf/static/superman/img/logo/bd_logo1_31bdc765.png)</span></span>;</span><br><span class="line">   <span class="rule"><span class="attribute">background-repeat</span>:<span class="value">no-repeat</span></span>;</span><br><span class="line">   <span class="rule"><span class="attribute">background-position</span>:<span class="value">right bottom</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>背景关联<br><code>background-attachment</code>设置背景图像是否随用户滚动而滚动。<code>fixed</code>不滚动,<code>scroll</code>是滚动。</li>
</ul>
<p><img src="https://cloud.githubusercontent.com/assets/8317477/23939580/53ead580-099c-11e7-98c0-10146edbe5a7.png" alt=""></p>
<h3 id="CSS_u6587_u672C"><a href="#CSS_u6587_u672C" class="headerlink" title="CSS文本"></a>CSS文本</h3><p>文本属性可定义文本的外观（颜色，字符间距，装饰文本，缩进）</p>
<ul>
<li><p>缩进文本(<code>text-indent</code>)</p>
<pre><code><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">text-indent</span>:<span class="value"><span class="number">5em</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
</code></pre></li>
</ul>
<ul>
<li>水平对齐(<code>text-align</code>)</li>
<li>字间隔(    <code>word-spacing</code>)</li>
<li>字母间隔(<code>letter-spacing</code>)</li>
<li>字符转换(<code>text-transform</code>)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">h1</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">text-transform</span>:<span class="value">uppercase</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文本装饰(<code>text-decoration</code>)</li>
</ul>
<blockquote>
<p>可选的值:<code>none</code>,<code>underline</code>,<code>overline</code>,<code>line-through</code>,<code>blink</code></p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class">.decoration</span><span class="rules">&#123;</span><br><span class="line">              <span class="rule"><span class="attribute">text-decoration</span>:<span class="value"> underline</span></span>;</span><br><span class="line">          &#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>处理空白符(<code>text-space</code>)</li>
</ul>
<p>影响对文档中的空格、换行和tab字符的处理。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">white-space</span>:<span class="value">normal</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>文本方向(<code>direction</code>)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">direction</span>:<span class="value">rtl</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="CSS__u5B57_u4F53"><a href="#CSS__u5B57_u4F53" class="headerlink" title="CSS 字体"></a>CSS 字体</h3><p>定义文本的字体系列，大小，加粗，风格（如斜体）和变型（如小型大写字母）</p>
<ul>
<li>字体系列</li>
</ul>
<blockquote>
<p>分为通用(如<code>Serif</code>)和特定系列(如<code>Times</code>)</p>
</blockquote>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">body</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">font-family</span>:<span class="value">sans-serif</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>字体风格(<code>font-style</code>)</li>
</ul>
<blockquote>
<p>三个值<code>normal</code>,<code>italic</code>,<code>oblique</code></p>
</blockquote>
<ul>
<li>字体变形(<code>font-variant</code>)</li>
<li><p>字体加粗(<code>font-weight</code>)</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">p</span><span class="class">.normal</span> <span class="rules">&#123;<span class="rule"><span class="attribute">font-weight</span>:<span class="value">normal</span></span>;&#125;</span></span><br><span class="line"><span class="tag">p</span><span class="class">.thick</span> <span class="rules">&#123;<span class="rule"><span class="attribute">font-weight</span>:<span class="value">bold</span></span>;&#125;</span></span><br><span class="line"><span class="tag">p</span><span class="class">.thicker</span> <span class="rules">&#123;<span class="rule"><span class="attribute">font-weight</span>:<span class="value"><span class="number">900</span></span></span>;&#125;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li>字体大小(<code>font-size</code>)</li>
</ul>
<p><img src="https://cloud.githubusercontent.com/assets/8317477/23980223/667c6108-0a39-11e7-9437-5351660b2f24.png" alt=""></p>
<h3 id="CSS__u94FE_u63A5"><a href="#CSS__u94FE_u63A5" class="headerlink" title="CSS 链接"></a>CSS 链接</h3><ul>
<li>设置链接样式</li>
</ul>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">   a:link&#123;</span><br><span class="line">      <span class="built_in">color</span>:<span class="built_in">red</span>;</span><br><span class="line">      <span class="built_in">text</span>-decoration: none;</span><br><span class="line">   &#125;</span><br><span class="line">   a:visited&#123;</span><br><span class="line">       <span class="built_in">color</span>:<span class="built_in">green</span>;</span><br><span class="line">       <span class="built_in">text</span>-decoration: none;</span><br><span class="line">   &#125;</span><br><span class="line">   a:hover&#123;</span><br><span class="line">      <span class="built_in">color</span>: #ff00ff;</span><br><span class="line">      <span class="built_in">text</span>-decoration: underline;</span><br><span class="line">    &#125;</span><br><span class="line">   a:active&#123;</span><br><span class="line">       <span class="built_in">color</span>: <span class="built_in">blue</span>;</span><br><span class="line">       <span class="built_in">text</span>-decoration: underline;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">&lt;a href=<span class="string">"http://baidu.com"</span> target=<span class="string">"_blank"</span>&gt;百度一下&lt;/a&gt;</span><br></pre></td></tr></table></figure>
<h3 id="CSS_u5217_u8868"><a href="#CSS_u5217_u8868" class="headerlink" title="CSS列表"></a>CSS列表</h3><ul>
<li>列表标志类型(<code>list-style-type</code>)</li>
<li>列表项图像(<code>list-style-image</code>)</li>
<li>列表标志位置(<code>list-style-position</code>)</li>
<li>简写列表样式(<code>list-style</code>)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ul</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">list-style-type</span>:<span class="value">square</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">ul</span> <span class="tag">li</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">list-style-image</span>:<span class="value"><span class="function">url</span>(xx.gif)</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">ul</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">list-style-position</span>:<span class="value">inside</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line">&lt;!<span class="tag">--</span>简写<span class="tag">--</span>&gt;</span><br><span class="line"><span class="tag">li</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">list-style</span>:<span class="value"><span class="function">url</span>(xx.gif) square inside</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<h3 id="CSS__u8868_u683C"><a href="#CSS__u8868_u683C" class="headerlink" title="CSS 表格"></a>CSS 表格</h3><ul>
<li>表格边框(<code>border</code>)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">table</span>,<span class="tag">th</span>,<span class="tag">td</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid blue</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>折叠边框(<code>border-collapse</code>)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">table</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border-collapse</span>:<span class="value">collapse</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>宽度和高度(<code>width</code> 和 <code>height</code>)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">table</span><span class="rules">&#123;</span><br><span class="line">   <span class="rule"><span class="attribute">width</span>:<span class="value"><span class="number">100%</span></span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="tag">th</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">50px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>表格文本对齐(<code>text-align</code>和<code>vertical-align</code>)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;!<span class="tag">--</span>水平对齐<span class="tag">--</span>&gt;</span><br><span class="line"><span class="tag">td</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">text-align</span>:<span class="value">right</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"></span><br><span class="line">&lt;!<span class="tag">--</span>垂直对齐<span class="tag">--</span>&gt;</span><br><span class="line"><span class="tag">td</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">height</span>:<span class="value"><span class="number">50px</span></span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">vertical-align</span>:<span class="value">bottom</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>表格内边距(<code>padding</code>)</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">td</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">padding</span>:<span class="value"><span class="number">15px</span></span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>表格颜色</li>
</ul>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">table</span>,<span class="tag">td</span>,<span class="tag">th</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">border</span>:<span class="value"><span class="number">1px</span> solid green</span></span>;</span><br><span class="line">&#125;</span></span><br><span class="line"><span class="tag">th</span><span class="rules">&#123;</span><br><span class="line">  <span class="rule"><span class="attribute">background-color</span>:<span class="value">green</span></span>;</span><br><span class="line">  <span class="rule"><span class="attribute">color</span>:<span class="value">white</span></span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p><img src="https://cloud.githubusercontent.com/assets/8317477/23984246/7d1dfede-0a53-11e7-9ed7-7aae5242d0c2.png" alt=""></p>
<h3 id="CSS_u8F6E_u5ED3"><a href="#CSS_u8F6E_u5ED3" class="headerlink" title="CSS轮廓"></a>CSS轮廓</h3><p>轮廓绘制元素周围的一条线，用于突出元素。</p>
<p><img src="https://cloud.githubusercontent.com/assets/8317477/23984383/41f1388e-0a54-11e7-9ff7-ce5761b5e1d8.png" alt=""></p>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;CSS__u80CC_u666F&quot;&gt;&lt;a href=&quot;#CSS__u80CC_u666F&quot; class=&quot;headerlink&quot; title=&quot;CSS 背景&quot;&gt;&lt;/a&gt;CSS 背景&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;背景色&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;back
    
    </summary>
    
    
      <category term="学习笔记" scheme="http://johntsai.work/tags/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>理解RxJava:(四)Reactive Android</title>
    <link href="http://johntsai.work/2016/07/27/%E7%90%86%E8%A7%A3RxJava(%E5%9B%9B)Reactive%20Android/"/>
    <id>http://johntsai.work/2016/07/27/理解RxJava(四)Reactive Android/</id>
    <published>2016-07-27T02:45:00.000Z</published>
    <updated>2017-03-01T08:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>在前三部分，我在通用层面介绍了RxJava的工作原理。但是作为一个Android开发者，如何在工作中使用它呢?下面是一些给Android开发者的RxJava的具体应用。</p>
<h2 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h2><p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a>是RxJava在Android开发中的拓展。它包含能节省我们大量时间的特殊bindings。</p>
<p>首先，其中有<code>AndroidSchedulers</code>，它能提供专门为Android线程系统提供的schedulers。需要在UI线程运行代码?没问题——只需要使用<code>AndroidSchedulers.mainThread()</code>方法即可:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">retrofitService</span><span class="class">.getImage</span>(<span class="tag">url</span>)</span><br><span class="line">    <span class="class">.subscribeOn</span>(<span class="tag">Schedulers</span><span class="class">.io</span>())</span><br><span class="line">    <span class="class">.observeOn</span>(<span class="tag">AndroidSchedulers</span><span class="class">.mainThread</span>())</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">bitmap</span> <span class="tag">-</span>&gt; <span class="tag">myImageView</span><span class="class">.setImageBitmap</span>(<span class="tag">bitmap</span>));</span><br></pre></td></tr></table></figure>
<p>如果你拿到的是<code>Handler</code>，可以通过<code>HandlerThreadScheduler</code>创建一个scheduler绑定在Handler上。</p>
<p>接下来介绍的是<code>AndroidObservable</code>，它能提供很多在Android生命周期中的特色功能。<code>bindActivity()</code>和<code>bindFragment()</code>方法能停止发出items，在<code>Activity</code>或<code>Fragment</code>结束的时候。另外会自动为订阅使用<code>AndroidSchedulers.mainThread()</code>。（因此你不需要在Activity或Fragment无效的时候来改变状态）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">AndroidObservable</span><span class="class">.bindActivity</span>(<span class="tag">this</span>, <span class="tag">retrofitService</span><span class="class">.getImage</span>(<span class="tag">url</span>))</span><br><span class="line">    <span class="class">.subscribeOn</span>(<span class="tag">Schedulers</span><span class="class">.io</span>())</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">bitmap</span> <span class="tag">-</span>&gt; <span class="tag">myImageView</span><span class="class">.setImageBitmap</span>(<span class="tag">bitmap</span>));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>我也喜欢<code>AndroidObservable.fromBroadcast()</code>，它让我们可以创建一个像<code>BroadcastReceiver</code>那样工作的<code>Observable</code>。以下是无论什么时候网络连接发生变化时通知的方法。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter <span class="built_in">filter</span> = <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">AndroidObservable.fromBroadcast(context, <span class="built_in">filter</span>)</span><br><span class="line">    .subscribe(intent -&gt; handleConnectivityChange(intent));</span><br></pre></td></tr></table></figure>
<p>最后介绍的是<code>ViewObservable</code>，它能为<code>Views</code>添加<code>bindings</code>。如果你想要得到<code>View</code>每次被点击的事件，可以通过<code>ViewObservable.clicks()</code>方法。也可以通过<code>ViewObservable.text()</code>方法来监测<code>TextView</code>的内容发生的任何变化。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ViewObservable</span><span class="class">.clicks</span>(<span class="tag">mCardNameEditText</span>, <span class="tag">false</span>)</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">view</span> <span class="tag">-</span>&gt; <span class="tag">handleClick</span>(<span class="tag">view</span>));</span><br></pre></td></tr></table></figure>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p> 有一个知名并且支持RxJava的库：<a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a>，它是Android开发中的非常出名的REST风格的网络库。通常，我们定义一个异步方法并添加<code>Callback</code>:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GET</span>(<span class="string">"/user/&#123;id&#125;/photo"</span>)</span><br><span class="line">void <span class="function">getUserPhoto</span>(<span class="variable">@Path</span>(<span class="string">"id"</span>) int id, Callback&lt;Photo&gt; cb);</span><br></pre></td></tr></table></figure>
<p>用了RxJava，可以用<code>Observable</code>代替<code>Callback</code>作为返回值。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GET</span>(<span class="string">"/user/&#123;id&#125;/photo"</span>)</span><br><span class="line">Observable&lt;Photo&gt; <span class="function">getUserPhoto</span>(<span class="variable">@Path</span>(<span class="string">"id"</span>) int id);</span><br></pre></td></tr></table></figure>
<p>现在可以对<code>Observable</code>做你想要的操作了，不仅可以获得数据，也能变换它。</p>
<p>Retrofit支持<code>Observable</code>，也使得合并多个REST请求变得容易。例如，假设我们有一个请求获得图片，另一个请求获得元数据(metadata)。我们可以把结果组合到一起:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.zip<span class="comment">(</span><br><span class="line">    service.getUserPhoto(id)</span>,</span><br><span class="line">    service.getPhotoMetadata<span class="comment">(id)</span>,</span><br><span class="line">    <span class="comment">(photo, metadata)</span> -&gt; createPhotoWithData<span class="comment">(photo, metadata)</span>)</span><br><span class="line">    .subscribe<span class="comment">(photoWithData -&gt; showPhoto(photoWithData)</span>);</span><br></pre></td></tr></table></figure>
<p>我在<a href="">第二部分</a>展示了相似的例子（使用<code>flatMap()</code>）。这便证明使用RxJava+Retrofit合并多个REST请求有多简单。</p>
<h2 id="u65E7_u7684_uFF0C_u8017_u65F6_u957F_u7684_u4EE3_u7801"><a href="#u65E7_u7684_uFF0C_u8017_u65F6_u957F_u7684_u4EE3_u7801" class="headerlink" title="旧的，耗时长的代码"></a>旧的，耗时长的代码</h2><p>Retrofit能返回<code>Observerables</code>这固然非常好，但是如果你用的其他的库不支持它呢？或者你想要将一些内部代码转换为<code>Observables</code>？总之，你如何将旧的代码和新的代码联系在一起，而不用重写所有代码?</p>
<p><code>Observable.just()</code>和<code>Observable.from()</code>大多数时候足以将以前的代码转换为<code>Observable</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">oldMethod</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;Object&gt; <span class="title">newMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.just(oldMethod());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这在<code>oldMethod()</code>耗时少的情况下能正常工作，但是如果耗时长呢？因为调用<code>oldMethod()</code>，在它被传递到<code>Observable.just()</code>方法前就会阻塞了线程。</p>
<p>为了对付这个问题，以下是我一直使用的方法——使用<code>defer</code>方法将耗时长的部分包装起来。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Object slowBlockingMethod() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public Observable&lt;Object&gt; newMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer<span class="function"><span class="params">(() -&gt; Observable.just(slowBlockingMethod()))</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在，    直到你订阅<code>Observable</code>才会去调用<code>slowBlockMethod()</code>方法。</p>
<h2 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h2><p>我把最难的部分留在了最后。你是如何处理RxJava与Activity的生命周期的（配合使用的）？以下两个问题会多次出现：</p>
<ul>
<li><p>1.Activity的配置发生变化后继续订阅一个<code>Subscribtion</code></p>
<p>假设你用Retrofit做了一次REST请求，想要把请求结果展示在<code>ListView</code>上。如果用户旋转了屏幕怎么办？如果你想要继续相同的请求，但是如何做呢？</p>
</li>
<li><p>2.<code>Observables</code>持有<code>Context</code>引用会造成内存泄漏。</p>
<p> 这个问题是由于创建了一个以某种方式持有<code>Context</code>的<code>subscribtion</code>，特别是你和<code>Views</code>交互的时候容易出现。如果<code>Observable</code>没有准时完成，最后可能持有非常多的额外内存。</p>
</li>
</ul>
<p>不幸的是，两个问题都没有很好的解决办法。但是有一些能节约你时间的指导方针。</p>
<p>第一个问题能用一些RxJava内置的缓存机制解决，因此你可以取消订阅/再订阅同一个<code>Observable</code>，而不需要重复它之前的(准备)工作。特别的，<code>cache()</code>(或是<code>replay()</code>)方法将继续在（方法）之下的请求（即使你取消订阅）。这意味着Activity重新生成时,你能重新开始新的subscription。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Photo&gt; request = service.getUserPhoto(id).cache();</span><br><span class="line">Subscription <span class="sub"><span class="keyword">sub</span> = request.subscribe(photo -&gt; handleUserPhoto(photo));</span></span><br><span class="line"></span><br><span class="line">// ...When the Activity is being recreated...</span><br><span class="line"><span class="sub"><span class="keyword">sub</span>.unsubscribe();</span></span><br><span class="line"></span><br><span class="line">// ...Once the Activity is recreated...</span><br><span class="line">request.subscribe(photo -&gt; handleUserPhoto(photo));</span><br></pre></td></tr></table></figure>
<p>注意我们在两种情况下，用的是同一个缓存的请求(<code>request</code>)，那种方式隐含的调用只会发生一次。存放请求的地方你自己决定，但是像所有的生命周期解决方案一样，它必须存放在生命周期之外的地方（一个保存的fragment，单例等等）。</p>
<p>第二问题可以通过根据生命周期正确的取消订阅来实现。通用的方法是用一个<code>CompositeSubscription</code>来持有所有的<code>Subscription</code>，然后在<code>onDestroy()</code>或<code>onDestroyView()</code>方法中取消所有的订阅。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompositeSubscription mCompositeSubscription</span><br><span class="line">    = <span class="keyword">new</span> CompositeSubscription();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCompositeSubscription.add(</span><br><span class="line">        AndroidObservable.bindActivity(<span class="keyword">this</span>, Observable.just(<span class="string">"Hello, World!"</span>))</span><br><span class="line">        .subscribe(s -&gt; System.out.println(s)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">    mCompositeSubscription.unsubscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，你可以创建一个根<code>Activity</code>或<code>Fragment</code>，顺带添加一个<code>CompositeSubscription</code>，随后可以相应的取消订阅。</p>
<p>注意，只要你调用了<code>CompositeSubscription.unsubscribe()</code>，该对象(｀CompositeSubscription｀)就不能用了。因为它会自动取消订阅随后你添加的任何事物。如果你今后想要使用这种方法，你必须创建一个新的<code>CompositeSubscription</code>作为替代。</p>
<p>两个问题的解决方法都涉及到添加代码，我希望有一天能出现不需要写这些样板代码就能解决这些问题的天才。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在前三部分，我在通用层面介绍了RxJava的工作原理。但是作为一个Android开发者，如何在工作中使用它呢?下面是一些给Android开发者的RxJava的具体应用。&lt;/p&gt;
&lt;h2 id=&quot;RxAndroid&quot;&gt;&lt;a href=&quot;#RxAndroid&quot; class=&quot;headerlink&quot; title=&quot;RxAndroid&quot;&gt;&lt;/a&gt;RxAndroid&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxAndroid&quot;&gt;RxAndroid&lt;/a&gt;是RxJava在Android开发中的拓展。它包含能节省我们大量时间的特殊bindings。&lt;/p&gt;
&lt;p&gt;首先，其中有&lt;code&gt;AndroidSchedulers&lt;/code&gt;，它能提供专门为Android线程系统提供的schedulers。需要在UI线程运行代码?没问题——只需要使用&lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt;方法即可:&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;retrofitService&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.getImage&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;url&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;.subscribeOn&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;Schedulers&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.io&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;.observeOn&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;AndroidSchedulers&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.mainThread&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;.subscribe&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;bitmap&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt;&amp;gt; &lt;span class=&quot;tag&quot;&gt;myImageView&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.setImageBitmap&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;bitmap&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;如果你拿到的是&lt;code&gt;Handler&lt;/code&gt;，可以通过&lt;code&gt;HandlerThreadScheduler&lt;/code&gt;创建一个scheduler绑定在Handler上。&lt;/p&gt;
&lt;p&gt;接下来介绍的是&lt;code&gt;AndroidObservable&lt;/code&gt;，它能提供很多在Android生命周期中的特色功能。&lt;code&gt;bindActivity()&lt;/code&gt;和&lt;code&gt;bindFragment()&lt;/code&gt;方法能停止发出items，在&lt;code&gt;Activity&lt;/code&gt;或&lt;code&gt;Fragment&lt;/code&gt;结束的时候。另外会自动为订阅使用&lt;code&gt;AndroidSchedulers.mainThread()&lt;/code&gt;。（因此你不需要在Activity或Fragment无效的时候来改变状态）。&lt;/p&gt;
&lt;figure class=&quot;highlight css&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;tag&quot;&gt;AndroidObservable&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.bindActivity&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;this&lt;/span&gt;, &lt;span class=&quot;tag&quot;&gt;retrofitService&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.getImage&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;url&lt;/span&gt;))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;.subscribeOn&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;Schedulers&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.io&lt;/span&gt;())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;class&quot;&gt;.subscribe&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;bitmap&lt;/span&gt; &lt;span class=&quot;tag&quot;&gt;-&lt;/span&gt;&amp;gt; &lt;span class=&quot;tag&quot;&gt;myImageView&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.setImageBitmap&lt;/span&gt;(&lt;span class=&quot;tag&quot;&gt;bitmap&lt;/span&gt;));&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
      <category term="Java" scheme="http://johntsai.work/tags/Java/"/>
    
      <category term="RxJava" scheme="http://johntsai.work/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>理解RxJava:(三)RxJava的优点</title>
    <link href="http://johntsai.work/2016/07/26/%E7%90%86%E8%A7%A3RxJava(%E4%B8%89)RxJava%E7%9A%84%E4%BC%98%E7%82%B9/"/>
    <id>http://johntsai.work/2016/07/26/理解RxJava(三)RxJava的优点/</id>
    <published>2016-07-26T04:14:00.000Z</published>
    <updated>2016-07-26T01:45:01.000Z</updated>
    
    <content type="html"><![CDATA[<p>在第一部分，讲解了RxJava的基本结构。在第二部分，展示了operators的强大之处。但是你们可能仍然没有被说服，也没有足够的理由信服。下面是一些能让你信服的RxJava框架的优点。</p>
<h2 id="u9519_u8BEF_u5904_u7406"><a href="#u9519_u8BEF_u5904_u7406" class="headerlink" title="错误处理"></a>错误处理</h2><p>截至当前，我们一直都忽略<code>onComplete()</code>和<code>onError()</code>方法。它们标志着<code>Observable</code>停止发出items以及原因（不管是成功地完成或是不可恢复的错误）。</p>
<p>我们最初的<code>Subscriber</code>有能力监听<code>onComplete()</code>和<code>onError()</code>事件。动手实现如下所示：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="built_in">map</span>(s -&gt; potentialException(s))</span><br><span class="line">    .<span class="built_in">map</span>(s -&gt; anotherPotentialException(s))</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onNext(<span class="keyword">String</span> s) &#123; System.out.<span class="built_in">println</span>(s); &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onCompleted() &#123; System.out.<span class="built_in">println</span>(<span class="string">"Completed!"</span>); &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onError(Throwable e) &#123; System.out.<span class="built_in">println</span>(<span class="string">"Ouch!"</span>); &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>假设<code>potentialException()</code>和<code>anotherPotentialException()</code>都能抛出异常。每个<code>Observable</code>都以调用<code>onCompleted()``onError()</code>方法结束。正因为这样， 程序的输出要么是<code>Completed!</code>，要么是<code>Ouch!</code>(因为异常的抛出)<br><a id="more"></a><br>关于这个的补充：</p>
<ul>
<li><p>1.<strong><code>onError()</code>方法在有异常在任意时候被抛出的时候被调用。</strong></p>
<blockquote>
<p>这使得错误处理变得更简单。只需要在最后的时候在一个简单的方法中处理所有的错误即可。</p>
</blockquote>
</li>
<li><p>2.<strong>operators不需要处理异常</strong>。</p>
<blockquote>
<p>在<code>Observable</code>链上抛出的任何异常都可以留给    <code>Subscriber</code>决定如何处理。因为<code>onError()</code>方法之前的异常都会被跳过。    </p>
</blockquote>
</li>
</ul>
<ul>
<li><p>3.我们能知道<code>Subscriber</code>完成接收items的时候。</p>
<blockquote>
<p>知道任务什么时候结束有助于代码的流动。</p>
</blockquote>
<p>在错误处理上， 这个模式要比传统的错误处理简单得多。使用回调，必须在每个回调中处理错误。不仅仅是造成重复代码，也意味着每个回调都需要知道如何处理错误，意味着你的回调代码和调用者高度耦合。</p>
<p>通过RxJava，<code>Observable</code>不需要知道如何处理错误。operators不仅仅不需要处理错误状态，在关键错误发生时，它们会自动跳过。我们可以把所有的错误处理交给<code>Subscriber</code>。</p>
</li>
</ul>
<h2 id="u8C03_u5EA6_u8005_uFF08Schedulers_uFF09"><a href="#u8C03_u5EA6_u8005_uFF08Schedulers_uFF09" class="headerlink" title="调度者（Schedulers）"></a>调度者（Schedulers）</h2><p>你有一个需要做网络请求的Android应用。因为可能需要耗费很长时间，于是你在其它线程做网络请求。一般都会遇到这样的问题。</p>
<p>Android应用的多线程操作很难是因为你必须在正确的线程运行对的代码。否则应用会闪退。经典的错误就是当你在非主线程修改View的状态。</p>
<p>在RxJava中，我们能通过<code>subscribeOn()</code>方法指定<code>Observer</code>代码运行的线程，以及<code>observeOn()</code>方法指定<code>Subscriber</code>运行的线程。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">myObservableServices</span><span class="class">.retrieveImage</span>(<span class="tag">url</span>)</span><br><span class="line">    <span class="class">.subscribeOn</span>(<span class="tag">Schedulers</span><span class="class">.io</span>())</span><br><span class="line">    <span class="class">.observeOn</span>(<span class="tag">AndroidSchedulers</span><span class="class">.mainThread</span>())</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">bitmap</span> <span class="tag">-</span>&gt; <span class="tag">myImageView</span><span class="class">.setImageBitmap</span>(<span class="tag">bitmap</span>));</span><br></pre></td></tr></table></figure>
<p>多么简单？我的<code>Subscriber</code>之前的都运行在I/O线程。最后，View的操作发生在主线程。</p>
<p>最厉害的部分是我能绑定<code>subcribeOn()</code>和<code>observeOn()</code>方法到任意的<code>Observable</code>上。<br>它们仅仅是operators。我不需要担心<code>Observable</code>和之前的operators在做什么。在最后仅仅操作这个就轻易的实现线程的切换。</p>
<h2 id="u8BA2_u9605_uFF08Subscriptions_uFF09"><a href="#u8BA2_u9605_uFF08Subscriptions_uFF09" class="headerlink" title="订阅（Subscriptions）"></a>订阅（Subscriptions）</h2><p>还有些东西没有讲解。当你调用<code>Observable.subscribe()</code>，返回的是<code>Subscription</code>。这代表着你的<code>Observable</code>和<code>Subscriber</code>之间的联系：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Subscription </span><span class="keyword">subscription </span>= Observable.just(<span class="string">"Hello, World!"</span>)</span><br><span class="line">    .<span class="keyword">subscribe(s </span>-&gt; System.out.println(s))<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>可以使用<code>Subscription</code>来断绝这个联系：</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">subscription.unsubscribe();</span><br><span class="line"></span><span class="label">System.out.println</span>(<span class="string">"Unsubscribed="</span> + <span class="keyword">subscription.isUnsubscribed());</span><br><span class="line"></span>// 输出 <span class="string">"Unsubscribed=true"</span></span><br></pre></td></tr></table></figure>
<p>RxJava取消订阅的优点是它能停止方法链。如果你有一个复杂的operators链，调用<code>unsubscribe</code>方法将终止当前正在运行的代码。无需额外的操作。</p>
<h2 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h2><p>记住这几篇都是RxJava的入门文章。你们要学的比我现在所讲的要多得多。例如，研读<a href="https://github.com/ReactiveX/RxJava/wiki/Backpressure" target="_blank" rel="external">backpressure</a>。我不会在所有地方都用响应式编程。而只会在我想要把复杂逻辑变得更简单的地方使用。</p>
<p>最初，我计划这篇文章是这系列的最后一篇。但是一个常见的需求是RxJava在Android中的实际运用。因此，你能继续阅读第四部分。我希望这个入门系列能引导你们开始学习使用这个有趣的框架。如果你想要进一步学习，我建议阅读<a href="https://github.com/ReactiveX/RxJava/wiki" target="_blank" rel="external">RxJava的官方wiki</a>。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在第一部分，讲解了RxJava的基本结构。在第二部分，展示了operators的强大之处。但是你们可能仍然没有被说服，也没有足够的理由信服。下面是一些能让你信服的RxJava框架的优点。&lt;/p&gt;
&lt;h2 id=&quot;u9519_u8BEF_u5904_u7406&quot;&gt;&lt;a href=&quot;#u9519_u8BEF_u5904_u7406&quot; class=&quot;headerlink&quot; title=&quot;错误处理&quot;&gt;&lt;/a&gt;错误处理&lt;/h2&gt;&lt;p&gt;截至当前，我们一直都忽略&lt;code&gt;onComplete()&lt;/code&gt;和&lt;code&gt;onError()&lt;/code&gt;方法。它们标志着&lt;code&gt;Observable&lt;/code&gt;停止发出items以及原因（不管是成功地完成或是不可恢复的错误）。&lt;/p&gt;
&lt;p&gt;我们最初的&lt;code&gt;Subscriber&lt;/code&gt;有能力监听&lt;code&gt;onComplete()&lt;/code&gt;和&lt;code&gt;onError()&lt;/code&gt;事件。动手实现如下所示：&lt;/p&gt;
&lt;figure class=&quot;highlight processing&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Observable.just(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(s -&amp;gt; potentialException(s))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .&lt;span class=&quot;built_in&quot;&gt;map&lt;/span&gt;(s -&amp;gt; anotherPotentialException(s))&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .subscribe(&lt;span class=&quot;keyword&quot;&gt;new&lt;/span&gt; Subscriber&amp;lt;&lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt;&amp;gt;() &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onNext(&lt;span class=&quot;keyword&quot;&gt;String&lt;/span&gt; s) &amp;#123; System.out.&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(s); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onCompleted() &amp;#123; System.out.&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Completed!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        @Override&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;keyword&quot;&gt;void&lt;/span&gt; onError(Throwable e) &amp;#123; System.out.&lt;span class=&quot;built_in&quot;&gt;println&lt;/span&gt;(&lt;span class=&quot;string&quot;&gt;&quot;Ouch!&quot;&lt;/span&gt;); &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;假设&lt;code&gt;potentialException()&lt;/code&gt;和&lt;code&gt;anotherPotentialException()&lt;/code&gt;都能抛出异常。每个&lt;code&gt;Observable&lt;/code&gt;都以调用&lt;code&gt;onCompleted()``onError()&lt;/code&gt;方法结束。正因为这样， 程序的输出要么是&lt;code&gt;Completed!&lt;/code&gt;，要么是&lt;code&gt;Ouch!&lt;/code&gt;(因为异常的抛出)&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
      <category term="Java" scheme="http://johntsai.work/tags/Java/"/>
    
      <category term="RxJava" scheme="http://johntsai.work/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>理解RxJava:(二)Operator，Operator</title>
    <link href="http://johntsai.work/2016/07/23/%E7%90%86%E8%A7%A3RxJava(%E4%BA%8C)Operator%EF%BC%8COperator/"/>
    <id>http://johntsai.work/2016/07/23/理解RxJava(二)Operator，Operator/</id>
    <published>2016-07-23T14:14:00.000Z</published>
    <updated>2016-07-25T03:01:52.000Z</updated>
    
    <content type="html"><![CDATA[<p>在<a href="https://johntsai.xyz/2016/07/22/%E7%90%86%E8%A7%A3RxJava%28%E4%B8%80%29%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" target="_blank" rel="external">第一部分</a>，我讲解了RxJava的基本结构，也介绍了<code>map()</code>操作。然而，我能理解你仍旧不会选择使用Rxjava——你仍然还有很多东西没有学到。但是这个情况将很快得到改变。Rxjava一大部分的能力是因为其中的operators。</p>
<p>让我们通过一个例子来向你们介绍更多的operators。</p>
<h2 id="u521D_u59CB"><a href="#u521D_u59CB" class="headerlink" title="初始"></a>初始</h2><p>假设我有一个这样的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个基于文本查询网站链接的列表</span></span><br><span class="line">Observable&lt;List&lt;String&gt;&gt; query(String text);</span><br></pre></td></tr></table></figure>
<p>我想要构建一个搜索文本和显示结果的强健系统。基于上篇文章我们学到的，以下是我们马上想到的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .subscribe(urls -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">            System.out.println(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这个答案让人非常不满意，因为失去了转换数据流的能力。如果我想要修改每个URL，只能在每个<code>Subscriber</code>里面修改。这就违背了使用<code>map()</code>操作的初衷。</p>
<p>我可以为ulrs-&gt;urls创建一个<code>map()</code>,但是每个<code>map()</code>的内部都有一个for－each循环。哎哟。<br><a id="more"></a></p>
<h2 id="u4E00_u7EBF_u5E0C_u671B"><a href="#u4E00_u7EBF_u5E0C_u671B" class="headerlink" title="一线希望"></a>一线希望</h2><p>有一个方法，<code>Observable.from()</code>，输入一些items，然后每次发出一个:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Observable.from(<span class="string">"url1"</span>, <span class="string">"url2"</span>, <span class="string">"url3"</span>)</span><br><span class="line">    .subscribe(url -&gt; System.out.println(url));</span><br></pre></td></tr></table></figure>
<p>看起来有些帮助，让我们看看：</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .subscribe(urls<span class="function"> -&gt;</span> &#123;</span><br><span class="line">        Observable.<span class="keyword">from</span>(urls)</span><br><span class="line">            .subscribe(url<span class="function"> -&gt;</span> System.out.println(url));</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>没有了for-each循环，但是代码显得很混乱。现在变成了多个嵌套的subscriptions了。除了代码丑陋以及难以修改外，也违背了RxJava的一些原则。</p>
<h2 id="u66F4_u597D_u7684_u65B9_u6CD5"><a href="#u66F4_u597D_u7684_u65B9_u6CD5" class="headerlink" title="更好的方法"></a>更好的方法</h2><p>屏住你的呼吸，因为你见到了你的救世主：<code>flatMap()</code>。</p>
<p><code>Observable.flatMap()</code>获取一个<code>Observable</code>的返回值，将值发给另一个取代它的<code>Observable</code>。如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;List&lt;String&gt;, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(List&lt;String&gt; urls)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Observable.from(urls);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(url -&gt; System.out.println(url));</span><br></pre></td></tr></table></figure>
<p>我写成完整的方法是为了你能看到发生了什么，但是用 lambda表达式简写看起来很棒：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">query</span>("<span class="tag">Hello</span>, <span class="tag">world</span>!")</span><br><span class="line">    <span class="class">.flatMap</span>(<span class="tag">urls</span> <span class="tag">-</span>&gt; <span class="tag">Observable</span><span class="class">.from</span>(<span class="tag">urls</span>))</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">url</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">url</span>));</span><br></pre></td></tr></table></figure>
<p><code>flatMap()</code>（看起来）很怪，对吗？为什么返回另一个<code>Observable</code>？核心概念是新的<code>Observable</code>返回的正是<code>Subscriber</code>所观察的。它不接收<code>List&lt;String&gt;</code>——它接收<code>Observable.from()</code>返回的一系列的单独的<code>Strings</code>。</p>
<h2 id="u6B64_u5916"><a href="#u6B64_u5916" class="headerlink" title="此外"></a>此外</h2><p>我强调这个观点几遍都不足够：<code>flatMap()</code>能返回任意想要的<code>Observable</code>。</p>
<p>假设我又有一个这样的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回网站的标题，若是404则返回null</span></span><br><span class="line"><span class="function">Observable&lt;String&gt; <span class="title">getTitle</span><span class="params">(String URL)</span></span>;</span><br></pre></td></tr></table></figure>
<p>原本是打印URL，现在我想要打印接收的每个网站的标题。但是有些问题：我的方法只对每次一个URL有效，而且它返回的不是String，它返回的是发出String的<code>Observable</code>。</p>
<p>有了<code>flatMap()</code>，解决这个问题很简单。在把一系列的URL分开为单独的items后，我可以在<code>flatMap()</code>方法中对于每个URL使用<code>getTitle()</code>，在它到达<code>Subscriber</code>前。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))</span><br><span class="line">    .flatMap(<span class="keyword">new</span> Func1&lt;String, Observable&lt;String&gt;&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">call</span><span class="params">(String url)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getTitle(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p>同样，使用lambda简写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))</span><br><span class="line">    .flatMap(url -&gt; getTitle(url))</span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p>很酷，对吧？我把几个返回<code>Observable</code>方法组合在一起。</p>
<p>不仅仅于此，我还将两个API调用组合在一条方法链上了。你们知道维持所有的API调用同步，必须在数据展示前将它们的回调写在一起，是有多痛苦？我们不用再忍受嵌套回调了。所有的逻辑都包在简短的响应式调用中了。</p>
<h2 id="u5927_u91CF_u7684Operators"><a href="#u5927_u91CF_u7684Operators" class="headerlink" title="大量的Operators"></a>大量的Operators</h2><p>到目前为止，我们仅仅学习了两种operators。有很多还没有学到。其他的operators能怎样改善我们的代码呢？</p>
<p><code>getTitle()</code>在URL404的时候返回null。我们不想要输出<code>&quot;null&quot;</code>。以下代码显示我们可以过滤掉null：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))</span><br><span class="line">    .flatMap(url -&gt; getTitle(url))</span><br><span class="line">    .filter(title -&gt; title != <span class="keyword">null</span>)</span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p><code>filter()</code>方法发出和它们接收到的同样的item，只在通过了boolean检查的情况下。</p>
<p>现在我们只想要最多显示5个结果：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .flatMap(urls -&gt; Observable.from(urls))</span><br><span class="line">    .flatMap(url -&gt; getTitle(url))</span><br><span class="line">    .filter(title -&gt; title != <span class="keyword">null</span>)</span><br><span class="line">    .take(<span class="number">5</span>)</span><br><span class="line">    .subscribe(title -&gt; System.out.println(title));</span><br></pre></td></tr></table></figure>
<p><code>take()</code>最多发出指定数量的item（如果少于5个标题，它会提前停止）。</p>
<p>现在我们想要存储每个标题到磁盘上：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    <span class="built_in">.</span>flatMap(urls <span class="subst">-&gt; </span>Observable<span class="built_in">.</span>from(urls))</span><br><span class="line">    <span class="built_in">.</span>flatMap(url <span class="subst">-&gt; </span>getTitle(url))</span><br><span class="line">    <span class="built_in">.</span>filter(title <span class="subst">-&gt; </span>title != <span class="built_in">null</span>)</span><br><span class="line">    <span class="built_in">.</span><span class="keyword">take</span>(<span class="number">5</span>)</span><br><span class="line">    <span class="built_in">.</span>doOnNext(title <span class="subst">-&gt; </span>saveTitle(title))</span><br><span class="line">    <span class="built_in">.</span>subscribe(title <span class="subst">-&gt; </span>System<span class="built_in">.</span>out<span class="built_in">.</span>println(title));</span><br></pre></td></tr></table></figure>
<p><code>doOnNext()</code>让我们可以在每次一个item被发出之前，添加额外的行为。</p>
<p>看操作数据流多么简单。你可以继续对数据添加操作而不会弄糟任何事情。</p>
<p><a href="https://github.com/ReactiveX/RxJava/wiki/Alphabetical-List-of-Observable-Operators" target="_blank" rel="external">RxJava有非常多的Operators</a>。这么多operators让我们被吓到，但是值得查阅一遍以知道哪个对我们有用。消化这些操作会花费点时间，但是我们能信手拈来的时候就能感受到Rxjava真正的强大。</p>
<p>以上都是官方提供的，我们甚至可以自定义operators！这超出了本文的讨论范围。但是只要你想你就能做到。</p>
<h2 id="So_What_3F"><a href="#So_What_3F" class="headerlink" title="So What?"></a>So What?</h2><p>如果你是个怀疑论者。你会问为什么要关注这些operators？</p>
<h3 id="u5173_u952E_u70B93_Operators_u8BA9_u4F60_u80FD_u5BF9_u6570_u636E_u6D41_u505A_u4EFB_u4F55_u4E8B"><a href="#u5173_u952E_u70B93_Operators_u8BA9_u4F60_u80FD_u5BF9_u6570_u636E_u6D41_u505A_u4EFB_u4F55_u4E8B" class="headerlink" title="关键点3 Operators让你能对数据流做任何事"></a>关键点3 Operators让你能对数据流做任何事</h3><p>唯一的限制就是你自己。</p>
<p>你可以处理复杂的逻辑，从使用简单的operators链开始。它将你的代码打破为可重组的零碎东西。这就是函数响应式编程。你用的越多，就越能改变你编程的思维。</p>
<p>另外，想想我们的代码一转换消费起来变得多容易。最后的例子，我们调用了两次API，操作数据，然后存储。但是<code>Subscriber</code>并不知道这些。它想的仅仅是消费<code>Observable&lt;String&gt;</code>。封装让编程更简单。</p>
<p>在第三部分，我们将继续了解RxJava的特性。比如错误处理和并发，和操作数据没有直接联系。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;a href=&quot;https://johntsai.xyz/2016/07/22/%E7%90%86%E8%A7%A3RxJava%28%E4%B8%80%29%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/&quot;&gt;第一部分&lt;/a&gt;，我讲解了RxJava的基本结构，也介绍了&lt;code&gt;map()&lt;/code&gt;操作。然而，我能理解你仍旧不会选择使用Rxjava——你仍然还有很多东西没有学到。但是这个情况将很快得到改变。Rxjava一大部分的能力是因为其中的operators。&lt;/p&gt;
&lt;p&gt;让我们通过一个例子来向你们介绍更多的operators。&lt;/p&gt;
&lt;h2 id=&quot;u521D_u59CB&quot;&gt;&lt;a href=&quot;#u521D_u59CB&quot; class=&quot;headerlink&quot; title=&quot;初始&quot;&gt;&lt;/a&gt;初始&lt;/h2&gt;&lt;p&gt;假设我有一个这样的方法：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//返回一个基于文本查询网站链接的列表&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;Observable&amp;lt;List&amp;lt;String&amp;gt;&amp;gt; query(String text);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;我想要构建一个搜索文本和显示结果的强健系统。基于上篇文章我们学到的，以下是我们马上想到的：&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;query(&lt;span class=&quot;string&quot;&gt;&quot;Hello, world!&quot;&lt;/span&gt;)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    .subscribe(urls -&amp;gt; &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &lt;span class=&quot;keyword&quot;&gt;for&lt;/span&gt; (String url : urls) &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            System.out.println(url);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;);&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;这个答案让人非常不满意，因为失去了转换数据流的能力。如果我想要修改每个URL，只能在每个&lt;code&gt;Subscriber&lt;/code&gt;里面修改。这就违背了使用&lt;code&gt;map()&lt;/code&gt;操作的初衷。&lt;/p&gt;
&lt;p&gt;我可以为ulrs-&amp;gt;urls创建一个&lt;code&gt;map()&lt;/code&gt;,但是每个&lt;code&gt;map()&lt;/code&gt;的内部都有一个for－each循环。哎哟。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
      <category term="Java" scheme="http://johntsai.work/tags/Java/"/>
    
      <category term="RxJava" scheme="http://johntsai.work/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>理解RxJava:(一)基础知识</title>
    <link href="http://johntsai.work/2016/07/22/%E7%90%86%E8%A7%A3RxJava(%E4%B8%80)%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    <id>http://johntsai.work/2016/07/22/理解RxJava(一)基础知识/</id>
    <published>2016-07-22T08:14:00.000Z</published>
    <updated>2016-07-25T03:01:40.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自<a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/" target="_blank" rel="external">Grokking RxJava, Part 1: The Basics</a>,著作权归原作者<a href="https://twitter.com/danlew42" target="_blank" rel="external">danlew</a>所有。译文由<a href="https://www.github.com/JohnTsaiAndroid" target="_blank" rel="external">JohnTsai</a>翻译。转载请注明出处，并保留此段声明。</p>
<p><a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a>这些天成为了Android开发者关注的新热点。唯一的问题是它在你刚接触时难以理解。当你习惯了命令式编程，函数响应式编程就变得难以理解。但是一旦你理解了它，它就变得很棒了。</p>
<p>我在这试着给你们带来不一样的RxJava。这一系列四篇文章的目标是带你们入门。我不会也不能讲解所有的东西。我只是想让你们对RxJava以及它的工作原理感兴趣。</p>
<h2 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h2><p>响应式代码的基本构成部分是<code>Observables</code>和<code>Subscribers</code>(<em>译者注：技术名词很难找到合适的中文翻译，所以维持原文不被翻译</em>)。<code>Observable</code>发出items，<code>Subscriber</code>消费这些items。</p>
<p>items如何被消费有一套规则。<code>Observable</code>发出任意数量的items（包括0个items），要么以成功完成终止，要么以发生错误终止。对于<code>Observable</code>的每个<code>Subscriber</code>,<code>Observable</code>调用<code>Subscriber.onNext()</code>方法任意次，然后调用<code>Subscriber.onComplete()</code>方法或<code>Subscriber.onError()</code>方法。</p>
<p>这看起来和我们用的<a href="https://en.wikipedia.org/wiki/Observer_pattern" target="_blank" rel="external">观察者模式</a>类似，但在一个关键地方不同——<code>Observables</code>在有人明确地订阅它之后才会开始发出items。换句话说，没有人去订阅，就不会发出订阅事件（<em>译者注：引申自<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest" target="_blank" rel="external">If a tree falls in a forest</a></em>）。</p>
<a id="more"></a>
<h2 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h2><p>让我们通过一个具体例子来看RxJava是如何运作的。首先，先创建一个基本的<code>Observable</code>:</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; myObservable = Observable.create(</span><br><span class="line">    new Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="variable">@Override</span></span><br><span class="line">        public void call(Subscriber&lt;? super String&gt; <span class="sub"><span class="keyword">sub</span>) &#123;</span></span><br><span class="line">            <span class="sub"><span class="keyword">sub</span>.onNext("Hello, world!");</span></span><br><span class="line">            <span class="sub"><span class="keyword">sub</span>.onCompleted();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>Observable</code>发出<code>Hello World</code>然后完成。现在创建一个<code>Subscriber</code>来消费掉数据。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Subscriber&lt;String&gt; mySubscriber = <span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123; System.out.println(s); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所有这些所做的是将<code>Observable</code>发出的每个String打印出来。</p>
<p>现在有了<code>myObservable</code>和<code>mySubscriber</code>,我们可以用<code>subscribe()</code>方法将它们连接起来。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(mySubscriber);</span><br><span class="line"><span class="regexp">//</span> 输出 <span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure>
<p>当订阅发生时，<code>myobservable</code>调用<code>subsriber</code>的<code>onNext()</code>和<code>onComplete()</code>方法。作为结果，<code>mySubscriber</code>输出<code>&quot;Hello,World&quot;</code>然后结束。</p>
<h2 id="u66F4_u7B80_u6D01_u7684_u4EE3_u7801"><a href="#u66F4_u7B80_u6D01_u7684_u4EE3_u7801" class="headerlink" title="更简洁的代码"></a>更简洁的代码</h2><p>为了输出<code>&quot;Hello,World!&quot;</code>,上面写了许多样板代码。这是因为我为了让你们能够明确发生了什么，选择了一种啰嗦的方式。RxJava提供了许多快捷写法让我们能写出更简洁的代码。</p>
<p>首先，简化<code>Observable</code>。RxJava有针对通用任务的多种内置<code>Observable</code>构建方法。在这种情况下，<code>Observable.just()</code>发出一个item然后完成结束，就像我们上面的代码:</p>
<figure class="highlight golo"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="typename">Observable</span>&lt;String&gt; myObservable =</span><br><span class="line">    <span class="typename">Observable</span>.just(<span class="string">"Hello, world!"</span>);</span><br></pre></td></tr></table></figure>
<p>然后，对于啰嗦的<code>Subscriber</code>。我们不关心<code>onCompleted()</code>和<code>onError()</code>方法，取而代之，我们可以用一个更简洁的类来定义在<code>onNext()</code>中做什么:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Action1&lt;<span class="keyword">String</span>&gt; onNextAction = <span class="keyword">new</span> Action1&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> call(<span class="keyword">String</span> s) &#123;</span><br><span class="line">        System.out.<span class="built_in">println</span>(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>Subscriber</code>每部分的Action都能自定义。<code>Observable.subscribe()</code>能处理一个，两个以及三个<code>Action</code>参数，以取代<code>onNext()</code>,<code>onError()</code>和<code>onComplete()</code>方法。复用我们之前的<code>Subscriber</code>,如下:</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(<span class="keyword">on</span>NextAction, <span class="keyword">on</span>ErrorAction, <span class="keyword">on</span>CompleteAction);</span><br></pre></td></tr></table></figure>
<p>然而，我们仅仅需要第一个参数，因为我们可以省略<code>onError()</code>和<code>onComplete()</code>方法:</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">myObservable.subscribe(onNextAction);</span><br><span class="line"><span class="regexp">//</span> 输出 <span class="string">"Hello, world!"</span></span><br></pre></td></tr></table></figure>
<p>现在，让我们通过方法的链式调用来取代这些变量:</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Action1&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> call(<span class="keyword">String</span> s) &#123;</span><br><span class="line">              System.out.<span class="built_in">println</span>(s);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>最后，用Java 8的lambdas表达式来去掉丑陋的<code>Action1</code>代码。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Observable</span><span class="class">.just</span>("<span class="tag">Hello</span>, <span class="tag">world</span>!")</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">s</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">s</span>));</span><br></pre></td></tr></table></figure>
<p>如果你在Android中使用（迄今为止不能使用Java8）(<em>译者注：原文作者写这篇文章的时候(2014年)Java8在Android中开发不能使用，在译者翻译这篇文章的时候（2016年），已经能使用部分特性了</em>)，我推荐使用<a href="https://github.com/evant/gradle-retrolambda" target="_blank" rel="external">retrolambda</a>,它将大幅降低代码的啰嗦程度。</p>
<h2 id="u53D8_u6362"><a href="#u53D8_u6362" class="headerlink" title="变换"></a>变换</h2><p>让我们把事情变得更有趣。</p>
<p>假设我想要在输出的<code>&quot;Hello,world!&quot;</code>语句中加上我的签名。一种可能（的实现方式）是改变<code>Observable</code>:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Observable</span><span class="class">.just</span>("<span class="tag">Hello</span>, <span class="tag">world</span>! <span class="tag">-Dan</span>")</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">s</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">s</span>));</span><br></pre></td></tr></table></figure>
<p>如果你能够控制你的<code>Observable</code>,这有效。但是不能保证以后都是这种情况。如果你使用的是别人的库呢？<br>另一种可能的问题是:如果我在多个地方使用我的<code>Observable</code>，但仅仅是某些情况下想要加上签名呢?</p>
<p>那修改我们的<code>Subscriber</code>怎样:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Observable</span><span class="class">.just</span>("<span class="tag">Hello</span>, <span class="tag">world</span>!")</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">s</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">s</span> + " <span class="tag">-Dan</span>"));</span><br></pre></td></tr></table></figure>
<p>这个回答同样不能让人满意，有不同的原因：我想要我的<code>Subscriber</code>尽可能轻量，因为我可能会在主线程上运行它们。在更概念的层次上理解，<code>Subscribers</code>被认定是做出反应(reacts)的事物，而不是做出转变(mutates)的事物。</p>
<p>如果我能够通过一些中间步骤将<code>&quot;Hello,world!&quot;</code>转换，是不是很酷？</p>
<h2 id="Operators_u4ECB_u7ECD"><a href="#Operators_u4ECB_u7ECD" class="headerlink" title="Operators介绍"></a>Operators介绍</h2><p>接下来是如何解决item转换问题:使用operators。Operators被用于在源<code>Observable</code>和最终的<code>Subscriber</code>之间操作被发出的items。RxJava推出了非常多的operators，但是刚开始我们仅仅需要关注少数几个。</p>
<p>对于这种情况，<code>map()</code>操作能被用于将一个被发出的item转化为另一个：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable<span class="built_in">.</span>just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    <span class="built_in">.</span><span class="built_in">map</span>(<span class="literal">new</span> Func1&lt;<span class="built_in">String</span>, <span class="built_in">String</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">String</span> call(<span class="built_in">String</span> s) &#123;</span><br><span class="line">            <span class="keyword">return</span> s + <span class="string">" -Dan"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">.</span>subscribe(s <span class="subst">-&gt; </span>System<span class="built_in">.</span>out<span class="built_in">.</span>println(s));</span><br></pre></td></tr></table></figure>
<p>同样的，我们能使用lambda来简化这个：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Observable</span><span class="class">.just</span>("<span class="tag">Hello</span>, <span class="tag">world</span>!")</span><br><span class="line">    <span class="class">.map</span>(<span class="tag">s</span> <span class="tag">-</span>&gt; <span class="tag">s</span> + " <span class="tag">-Dan</span>")</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">s</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">s</span>));</span><br></pre></td></tr></table></figure>
<p>非常酷，我们的<code>map()</code>操作是一个转换一个item的<code>Observable</code>。我们可以链式调用任意个<code>map()</code><br>，将数据改进，成为最终的<code>Subscriber</code>可消费的形式。</p>
<h2 id="u6DF1_u5165map_28_29"><a href="#u6DF1_u5165map_28_29" class="headerlink" title="深入map()"></a>深入map()</h2><p><code>map()</code>有一个有趣的方面：它不需要发出和源<code>Observable</code>相同类型的items！</p>
<p>假设我的<code>Subscriber</code>对输出原文本不感兴趣，想要输出原文本的hash码:</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable<span class="built_in">.</span>just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    <span class="built_in">.</span><span class="built_in">map</span>(<span class="literal">new</span> Func1&lt;<span class="built_in">String</span>, <span class="built_in">Integer</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="built_in">Integer</span> call(<span class="built_in">String</span> s) &#123;</span><br><span class="line">            <span class="keyword">return</span> s<span class="built_in">.</span>hashCode();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="built_in">.</span>subscribe(i <span class="subst">-&gt; </span>System<span class="built_in">.</span>out<span class="built_in">.</span>println(<span class="built_in">Integer</span><span class="built_in">.</span>toString(i)));</span><br></pre></td></tr></table></figure>
<p>非常有趣——我们以String开始但是我们的<code>Subscriber</code>接收的是一个Integer。</p>
<p>同样地，我们能使用lambda来简化代码：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Observable</span><span class="class">.just</span>("<span class="tag">Hello</span>, <span class="tag">world</span>!")</span><br><span class="line">    <span class="class">.map</span>(<span class="tag">s</span> <span class="tag">-</span>&gt; <span class="tag">s</span><span class="class">.hashCode</span>())</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">i</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">Integer</span><span class="class">.toString</span>(<span class="tag">i</span>)));</span><br></pre></td></tr></table></figure>
<p>就像我之前说的，我们想要<code>Subscriber</code>尽可能少做事。通过另一个<code>map()</code>来将hash码转化为String：</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">Observable</span><span class="class">.just</span>("<span class="tag">Hello</span>, <span class="tag">world</span>!")</span><br><span class="line">    <span class="class">.map</span>(<span class="tag">s</span> <span class="tag">-</span>&gt; <span class="tag">s</span><span class="class">.hashCode</span>())</span><br><span class="line">    <span class="class">.map</span>(<span class="tag">i</span> <span class="tag">-</span>&gt; <span class="tag">Integer</span><span class="class">.toString</span>(<span class="tag">i</span>))</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">s</span> <span class="tag">-</span>&gt; <span class="tag">System</span><span class="class">.out</span><span class="class">.println</span>(<span class="tag">s</span>));</span><br></pre></td></tr></table></figure>
<p> 你有没有发现——<code>Observable</code>和<code>Subscriber</code>回到了它们之前的样子了！我们仅仅在它们之间增加了一些转换步骤。甚至能够添加我的签名：</p>
 <figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable<span class="built_in">.</span>just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">   <span class="built_in">.</span><span class="built_in">map</span>(s <span class="subst">-&gt; </span>s + <span class="string">" -Dan"</span>)</span><br><span class="line">   <span class="built_in">.</span><span class="built_in">map</span>(s <span class="subst">-&gt; </span>s<span class="built_in">.</span>hashCode())</span><br><span class="line">   <span class="built_in">.</span><span class="built_in">map</span>(i <span class="subst">-&gt; </span><span class="built_in">Integer</span><span class="built_in">.</span>toString(i))</span><br><span class="line">   <span class="built_in">.</span>subscribe(s <span class="subst">-&gt; </span>System<span class="built_in">.</span>out<span class="built_in">.</span>println(s));</span><br></pre></td></tr></table></figure>
<h2 id="So_What_uFF1F"><a href="#So_What_uFF1F" class="headerlink" title="So What？"></a>So What？</h2><p>此刻你可能会想”对于一些简单的代码，用了很多花式步伐一样技巧”。对，那是简单的例子。但是有两点你需要掌握：</p>
<h3 id="u5173_u952E_u70B91_3AObservable_u548CSubscriber_u80FD_u505A_u4EFB_u4F55_u4E8B_u60C5"><a href="#u5173_u952E_u70B91_3AObservable_u548CSubscriber_u80FD_u505A_u4EFB_u4F55_u4E8B_u60C5" class="headerlink" title="关键点1:<code>Observable</code>和<code>Subscriber</code>能做任何事情"></a>关键点1:<code>Observable</code>和<code>Subscriber</code>能做任何事情</h3><p><code>Observale</code>可以是数据库查询，<code>Subscriber</code>得到结果并将它们显示在屏幕上。<code>Observable</code>可以是屏幕上的点击，<code>Subscriber</code>对它做出反应。<code>Observable</code>可以是从网络读取的字节流，<code>Subscriber</code>把它写入磁盘。</p>
<p>RxJava是个能够处理任何问题的通用框架。</p>
<h3 id="u5173_u952E_u70B92_3AObservable_u548CSubscriber_u72EC_u7ACB_u4E8E_u5728_u5B83_u4EEC_u4E4B_u95F4_u7684_u8F6C_u6362_u6B65_u9AA4"><a href="#u5173_u952E_u70B92_3AObservable_u548CSubscriber_u72EC_u7ACB_u4E8E_u5728_u5B83_u4EEC_u4E4B_u95F4_u7684_u8F6C_u6362_u6B65_u9AA4" class="headerlink" title="关键点2:<code>Observable</code>和<code>Subscriber</code>独立于在它们之间的转换步骤"></a>关键点2:<code>Observable</code>和<code>Subscriber</code>独立于在它们之间的转换步骤</h3><p>我可以调用任意次的<code>map</code>操作，在最初的源<code>Observable</code>和它最终的<code>Subscriber</code>之间。RxJava高度组件化：易于操作数据。只要操作于正确的输入输出数据，我可以制造一条无止尽的方法链。</p>
<p>综合以上两点，我们可以看到RxJava的巨大潜力。虽然此时我们仅仅有一个<code>map()</code>操作,这严重地限制了我们的能力。在第二部分，我们将深入研究更多RxJava的操作。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自&lt;a href=&quot;http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/&quot;&gt;Grokking RxJava, Part 1: The Basics&lt;/a&gt;,著作权归原作者&lt;a href=&quot;https://twitter.com/danlew42&quot;&gt;danlew&lt;/a&gt;所有。译文由&lt;a href=&quot;https://www.github.com/JohnTsaiAndroid&quot;&gt;JohnTsai&lt;/a&gt;翻译。转载请注明出处，并保留此段声明。&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/ReactiveX/RxJava&quot;&gt;RxJava&lt;/a&gt;这些天成为了Android开发者关注的新热点。唯一的问题是它在你刚接触时难以理解。当你习惯了命令式编程，函数响应式编程就变得难以理解。但是一旦你理解了它，它就变得很棒了。&lt;/p&gt;
&lt;p&gt;我在这试着给你们带来不一样的RxJava。这一系列四篇文章的目标是带你们入门。我不会也不能讲解所有的东西。我只是想让你们对RxJava以及它的工作原理感兴趣。&lt;/p&gt;
&lt;h2 id=&quot;u57FA_u7840_u77E5_u8BC6&quot;&gt;&lt;a href=&quot;#u57FA_u7840_u77E5_u8BC6&quot; class=&quot;headerlink&quot; title=&quot;基础知识&quot;&gt;&lt;/a&gt;基础知识&lt;/h2&gt;&lt;p&gt;响应式代码的基本构成部分是&lt;code&gt;Observables&lt;/code&gt;和&lt;code&gt;Subscribers&lt;/code&gt;(&lt;em&gt;译者注：技术名词很难找到合适的中文翻译，所以维持原文不被翻译&lt;/em&gt;)。&lt;code&gt;Observable&lt;/code&gt;发出items，&lt;code&gt;Subscriber&lt;/code&gt;消费这些items。&lt;/p&gt;
&lt;p&gt;items如何被消费有一套规则。&lt;code&gt;Observable&lt;/code&gt;发出任意数量的items（包括0个items），要么以成功完成终止，要么以发生错误终止。对于&lt;code&gt;Observable&lt;/code&gt;的每个&lt;code&gt;Subscriber&lt;/code&gt;,&lt;code&gt;Observable&lt;/code&gt;调用&lt;code&gt;Subscriber.onNext()&lt;/code&gt;方法任意次，然后调用&lt;code&gt;Subscriber.onComplete()&lt;/code&gt;方法或&lt;code&gt;Subscriber.onError()&lt;/code&gt;方法。&lt;/p&gt;
&lt;p&gt;这看起来和我们用的&lt;a href=&quot;https://en.wikipedia.org/wiki/Observer_pattern&quot;&gt;观察者模式&lt;/a&gt;类似，但在一个关键地方不同——&lt;code&gt;Observables&lt;/code&gt;在有人明确地订阅它之后才会开始发出items。换句话说，没有人去订阅，就不会发出订阅事件（&lt;em&gt;译者注：引申自&lt;a href=&quot;https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest&quot;&gt;If a tree falls in a forest&lt;/a&gt;&lt;/em&gt;）。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
      <category term="Java" scheme="http://johntsai.work/tags/Java/"/>
    
      <category term="RxJava" scheme="http://johntsai.work/tags/RxJava/"/>
    
  </entry>
  
  <entry>
    <title>Android问题小结</title>
    <link href="http://johntsai.work/2016/07/21/Android%E9%97%AE%E9%A2%98%E5%B0%8F%E7%BB%93/"/>
    <id>http://johntsai.work/2016/07/21/Android问题小结/</id>
    <published>2016-07-21T11:56:11.000Z</published>
    <updated>2017-03-17T02:06:51.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-Gradle_u7F16_u8BD1_u62A5_u9519_u5982_u4E0B_uFF1A"><a href="#1-Gradle_u7F16_u8BD1_u62A5_u9519_u5982_u4E0B_uFF1A" class="headerlink" title="1.Gradle编译报错如下："></a>1.Gradle编译报错如下：</h4><p><code>Failed to resolve: XXXX. Show in File, Show in Project Structure dialog</code></p>
<p>重启Android Studio并清除Cache</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Android Studio<span class="subst">-&gt;</span>File<span class="subst">-&gt;</span>Invalidate <span class="keyword">Cache</span> / restart</span><br></pre></td></tr></table></figure>
<h4 id="2-_u67E5_u770B_u5F53_u524DActivity_u7684_u540D_u5B57"><a href="#2-_u67E5_u770B_u5F53_u524DActivity_u7684_u540D_u5B57" class="headerlink" title="2.查看当前Activity的名字"></a>2.查看当前Activity的名字</h4><figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">adb <span class="keyword">shell</span> dumpsys <span class="keyword">window</span> windows | grep -<span class="keyword">E</span> 'mCurrentFocus|mFocusedApp'</span><br></pre></td></tr></table></figure>
<script src="https://gist.github.com/JohnTsaiAndroid/2e2239b5529518831db6576e7eac39d5.js"></script>

<h4 id="3-Android_Studio_u67E5_u770B_u7C7B_u7684_u7EE7_u627F_u5173_u7CFB"><a href="#3-Android_Studio_u67E5_u770B_u7C7B_u7684_u7EE7_u627F_u5173_u7CFB" class="headerlink" title="3.Android Studio查看类的继承关系"></a>3.Android Studio查看类的继承关系</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="constant">Windows</span><span class="symbol">:Crtl+H</span></span><br><span class="line"><span class="constant">Mac</span><span class="symbol">:Control+H</span></span><br></pre></td></tr></table></figure>
<h4 id="4-Android_Studio_u67E5_u770B_u6240_u6709_u65AD_u70B9"><a href="#4-Android_Studio_u67E5_u770B_u6240_u6709_u65AD_u70B9" class="headerlink" title="4.Android Studio查看所有断点"></a>4.Android Studio查看所有断点</h4><figure class="highlight ruby"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>.</span><br><span class="line">  <span class="constant">Run</span>--&gt;<span class="constant">View</span> <span class="constant">Breakpoints</span></span><br><span class="line"></span><br><span class="line"><span class="number">2</span>.</span><br><span class="line"><span class="constant">Windows</span><span class="symbol">:Shift+Control+F8</span></span><br><span class="line"><span class="constant">Mac</span><span class="symbol">:Shift+Command+F8</span></span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-Gradle_u7F16_u8BD1_u62A5_u9519_u5982_u4E0B_uFF1A&quot;&gt;&lt;a href=&quot;#1-Gradle_u7F16_u8BD1_u62A5_u9519_u5982_u4E0B_uFF1A&quot; class=&quot;headerlink&quot;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android:如何从堆栈中还原ProGuard混淆后的代码</title>
    <link href="http://johntsai.work/2016/07/19/Android%E5%A6%82%E4%BD%95%E4%BB%8E%E5%A0%86%E6%A0%88%E4%B8%AD%E8%BF%98%E5%8E%9FProGuard%E6%B7%B7%E6%B7%86%E5%90%8E%E7%9A%84%E4%BB%A3%E7%A0%81/"/>
    <id>http://johntsai.work/2016/07/19/Android如何从堆栈中还原ProGuard混淆后的代码/</id>
    <published>2016-07-19T06:41:00.000Z</published>
    <updated>2016-07-19T06:53:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文翻译自<a href="http://simplyadvanced.net/blog/android-how-to-decode-proguards-obfuscated-code-from-stack-trace/" target="_blank" rel="external">Android: How To Decode ProGuard’s Obfuscated Code From Stack Trace</a></p>
<p>本篇文章是写给那些在他们的应用中使用<a href="http://developer.android.com/tools/help/proguard.html" target="_blank" rel="external">ProGuard</a>并且需要从堆栈信息中进行调试的Android开发者。这是一种非常简单就将混淆的错误信息转化为可读的方法。</p>
<h3 id="u8FD8_u539F_u524D"><a href="#u8FD8_u539F_u524D" class="headerlink" title="还原前"></a>还原前</h3><p>以下是ProGuard混淆过的堆栈信息:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.be</span><span class="class">.u</span>(Unknown Source)</span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.at</span><span class="class">.v</span>(Unknown Source)</span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.at</span><span class="class">.d</span>(Unknown Source)</span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.av</span><span class="class">.onReceive</span>(Unknown Source)</span><br></pre></td></tr></table></figure>
<a id="more"></a> 
<h3 id="u8FD8_u539F_u540E"><a href="#u8FD8_u539F_u540E" class="headerlink" title="还原后"></a>还原后</h3><p>只要在命令行写一行命令，混淆都将会被移除，如下所示：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.UtilTelephony</span><span class="class">.boolean</span> <span class="function"><span class="title">is800MhzNetwork</span><span class="params">()</span><span class="params">(Unknown Source)</span></span></span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.ServiceDetectLte</span><span class="class">.void</span> <span class="function"><span class="title">checkAndAlertUserIf800MhzConnected</span><span class="params">()</span><span class="params">(Unknown Source)</span></span></span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.ServiceDetectLte</span><span class="class">.void</span> <span class="function"><span class="title">startLocalBroadcastReceiver</span><span class="params">()</span><span class="params">(Unknown Source)</span></span></span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.ServiceDetectLte</span>$<span class="number">2</span><span class="class">.void</span> <span class="function"><span class="title">onReceive</span><span class="params">(android.content.Context,android.content.Intent)</span><span class="params">(Unknown Source)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="u5982_u4F55_u8FD8_u539F_u5806_u6808_u4FE1_u606F"><a href="#u5982_u4F55_u8FD8_u539F_u5806_u6808_u4FE1_u606F" class="headerlink" title="如何还原堆栈信息"></a>如何还原堆栈信息</h3><p>可以选择命令行或者GUI</p>
<h4 id="GUI"><a href="#GUI" class="headerlink" title="GUI"></a>GUI</h4><ul>
<li>1.打开<code>/tools/proguard/bin/proguardgui.bat</code></li>
<li>2.选择左边栏的<code>ReTrace</code>选项</li>
<li>3.添加你的mapping文件和混淆过的堆栈信息</li>
<li>4.点击<code>ReTrace!</code></li>
</ul>
<p>如下图所示(译者注)<br><img src="http://7xr1jz.com1.z0.glb.clouddn.com/androidQQ20160719-0.png" alt=""></p>
<h4 id="u547D_u4EE4_u884C"><a href="#u547D_u4EE4_u884C" class="headerlink" title="命令行"></a>命令行</h4><ul>
<li>1.需要你的ProGuard的mapping文件和你想要还原的堆栈信息（如stacktrace.txt）</li>
<li>2.最简单的方法就是将这些文件拷贝到<code>/tools/proguard/bin/</code>目录</li>
<li>3.运行以下命令</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Windows</span></span><br><span class="line">retrace<span class="class">.bat</span> -verbose mapping<span class="class">.txt</span> stacktrace<span class="class">.txt</span> &gt; out<span class="class">.txt</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Mac/Linux</span></span><br><span class="line">retrace<span class="class">.sh</span> -verbose mapping<span class="class">.txt</span> stacktrace<span class="class">.txt</span> &gt; out.txt</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文翻译自&lt;a href=&quot;http://simplyadvanced.net/blog/android-how-to-decode-proguards-obfuscated-code-from-stack-trace/&quot;&gt;Android: How To Decode ProGuard’s Obfuscated Code From Stack Trace&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本篇文章是写给那些在他们的应用中使用&lt;a href=&quot;http://developer.android.com/tools/help/proguard.html&quot;&gt;ProGuard&lt;/a&gt;并且需要从堆栈信息中进行调试的Android开发者。这是一种非常简单就将混淆的错误信息转化为可读的方法。&lt;/p&gt;
&lt;h3 id=&quot;u8FD8_u539F_u524D&quot;&gt;&lt;a href=&quot;#u8FD8_u539F_u524D&quot; class=&quot;headerlink&quot; title=&quot;还原前&quot;&gt;&lt;/a&gt;还原前&lt;/h3&gt;&lt;p&gt;以下是ProGuard混淆过的堆栈信息:&lt;/p&gt;
&lt;figure class=&quot;highlight stylus&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;Caused by: java&lt;span class=&quot;class&quot;&gt;.lang&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.NullPointerException&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at net&lt;span class=&quot;class&quot;&gt;.simplyadvanced&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.ltediscovery&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.be&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.u&lt;/span&gt;(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at net&lt;span class=&quot;class&quot;&gt;.simplyadvanced&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.ltediscovery&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.at&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.v&lt;/span&gt;(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at net&lt;span class=&quot;class&quot;&gt;.simplyadvanced&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.ltediscovery&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.at&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.d&lt;/span&gt;(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;at net&lt;span class=&quot;class&quot;&gt;.simplyadvanced&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.ltediscovery&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.av&lt;/span&gt;&lt;span class=&quot;class&quot;&gt;.onReceive&lt;/span&gt;(Unknown Source)&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出经典面试题之——反转字符串</title>
    <link href="http://johntsai.work/2016/06/22/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%BB%8F%E5%85%B8%E9%9D%A2%E8%AF%95%E9%A2%98%E4%B9%8B%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://johntsai.work/2016/06/22/深入浅出经典面试题之——反转字符串/</id>
    <published>2016-06-22T05:14:00.000Z</published>
    <updated>2016-07-19T06:48:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h4><p>如今无论大小公司，都喜欢出一些算法题来测试面试者的算法功底或者说是计算机功底。而如今Android和Java把很多方法都封装成API了，导致我们写代码往往只是调调API，没有深入了解过一些功能的底层算法实现。因此，研究算法一是能在面试中正确快速的解决算法题，而是能提高我们的编程功底，更好地编写出高效稳健的代码。</p>
<p>今天，我们研究的是——<strong>反转字符串</strong>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入一个字符串，输出它的倒序字符串</span></span><br><span class="line"><span class="string">input:</span>  Hello</span><br><span class="line"><span class="string">output:</span> olleH</span><br></pre></td></tr></table></figure>
<h4 id="u51E0_u79CD_u89E3_u6CD5"><a href="#u51E0_u79CD_u89E3_u6CD5" class="headerlink" title="几种解法"></a>几种解法</h4>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">string</span>: <span class="string"> Hello</span></span><br><span class="line"><span class="attribute">length</span>: <span class="string"> 5</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">        <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">before: H e l l o</span><br><span class="line">after:  o l l e H</span><br><span class="line"></span><br><span class="line">index             sum</span><br><span class="line"><span class="number">0</span>: H---&gt;o  <span class="number">0</span>--&gt;<span class="number">4</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>: e---&gt;l  <span class="number">1</span>--&gt;<span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">2</span>: l---&gt;l  <span class="number">2</span>--&gt;<span class="number">2</span>  <span class="number">4</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分析字符串反转前后的规律可知:</span><br><span class="line">    两个反转字符串字符的下标之和为字符串长度-<span class="number">1.</span></span></span><br></pre></td></tr></table></figure>
<a id="more"></a> 
<h5 id="1-_u4F7F_u7528_u6570_u7EC4"><a href="#1-_u4F7F_u7528_u6570_u7EC4" class="headerlink" title="1.<strong>使用数组</strong>"></a>1.<strong>使用数组</strong></h5><p>  最常规的解法，也是我们在面试的时候最容易想到的一种方法。</p>
<p>  <strong>具体思路</strong>是:</p>
<pre><code>* 将字符串转换为char数组
* 遍历循环给char数组赋值
</code></pre><p>   <strong>编码实现</strong>：</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">     <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</span><br><span class="line">     <span class="keyword">int</span> length = string.length();</span><br><span class="line">     <span class="keyword">char</span> [] array = string.toCharArray();</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">         array[i] = string.charAt(length-<span class="number">1</span>-i);</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">new</span> String(array);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>  <strong>优化</strong>：</p>
<p>   分析上一种解法，循环遍历时，我们不需要循环这么多次。每次循环的时候，我们应该直接给前、后位置都赋值。</p>
<p>   <strong>编码实现</strong>:</p>
   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithArray2</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</span><br><span class="line">    <span class="keyword">int</span> length = string.length();</span><br><span class="line">    <span class="keyword">char</span> [] array = string.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt;length/<span class="number">2</span>;i++)&#123;</span><br><span class="line">        array[i] = string.charAt(length-<span class="number">1</span>-i);</span><br><span class="line">        array[length-<span class="number">1</span>-i] = string.charAt(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="2-_u4F7F_u7528_u6808"><a href="#2-_u4F7F_u7528_u6808" class="headerlink" title="2.<strong>使用栈</strong>"></a>2.<strong>使用栈</strong></h5><p>  我们都知道，栈有”后进先出(LIFO)”的特点。这一特点刚好用于反转字符串。</p>
<p>  <strong>具体思路</strong>是:</p>
<ul>
<li>将字符串转换为char数组</li>
<li>将char数组中的字符依次压入栈中</li>
<li><p>将栈中的字符依次弹出赋值给char数组</p>
<p><strong>编码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithStack</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</span><br><span class="line">    Stack&lt;Character&gt; stringStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    <span class="keyword">char</span> [] array = string.toCharArray();</span><br><span class="line">    <span class="keyword">for</span>(Character c:array)&#123;</span><br><span class="line">        stringStack.push(c);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> length = string.length();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i= <span class="number">0</span>;i&lt;length;i++)&#123;</span><br><span class="line">        array[i] = stringStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> String(array);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="3-_u9006_u5E8F_u904D_u5386"><a href="#3-_u9006_u5E8F_u904D_u5386" class="headerlink" title="3.<strong>逆序遍历</strong>"></a>3.<strong>逆序遍历</strong></h5><p>   仔细观察会发现，反转字符串实际上是逆序输出字符串中的字符。</p>
<p>   <strong>具体思路</strong>是:</p>
<ul>
<li>逆序遍历字符串中的字符，并将它依次添加到StringBuilder中</li>
</ul>
<p><strong>编码实现</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithReverseLoop</span><span class="params">(String string)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(string==<span class="keyword">null</span>||string.length()==<span class="number">0</span>)<span class="keyword">return</span> string;</span><br><span class="line">        StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = string.length()-<span class="number">1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            sb.append(string.charAt(i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="4-_u4F7F_u7528_u4F4D_u8FD0_u7B97"><a href="#4-_u4F7F_u7528_u4F4D_u8FD0_u7B97" class="headerlink" title="4.<strong>使用位运算</strong>"></a>4.<strong>使用位运算</strong></h5><p> 计算机的数据流本质上都是0，1二进制数据。字符串也是一样。而二进制数据的处理往往是通过位运算来实现的。位操作有:<strong>与，或，非，异或</strong>。</p>
<p> 对位运算有过了解的应该知道，使用<strong>异或操作</strong>能实现交换两个变量的值而不引入第三个变量。</p>
 <!-- more --> 
<p> <strong>实现原理</strong>:</p>
<ul>
<li><p>首先介绍异或操作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">异或操作: 当两两数值相同为否，而数值不同为真。写作A^B</span><br><span class="line"></span><br><span class="line">A  B  A^B</span><br><span class="line"><span class="number">0</span>  <span class="number">0</span>   <span class="number">0</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">1</span></span><br><span class="line"><span class="number">1</span>  <span class="number">0</span>   <span class="number">1</span></span><br><span class="line"><span class="number">0</span>  <span class="number">1</span>   <span class="number">0</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>使用异或操作交换数值</p>
<figure class="highlight parser3"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">两个数异或的结果再与其中一个数异或的结果是另外一个数</span><br><span class="line"></span><br><span class="line">这涉及到了离散数学中的异或的性质:</span><br><span class="line"></span><span class="number">1.</span><span class="xml">交换律:A</span><span class="keyword">^B</span><span class="xml">=B</span><span class="keyword">^A</span><span class="xml"></span><br><span class="line"></span><span class="number">2.</span><span class="xml">结合律: A^(B</span><span class="keyword">^C</span><span class="xml">)=(A</span><span class="keyword">^B</span><span class="xml">)</span><span class="keyword">^C</span><span class="xml"></span><br><span class="line"></span><span class="number">3.</span><span class="xml">恒等律:X</span><span class="keyword">^0</span><span class="xml">=</span><span class="number">0</span><span class="xml"></span><br><span class="line"></span><span class="number">4.</span><span class="xml">归零律:X</span><span class="keyword">^X</span><span class="xml">=</span><span class="number">0</span><span class="xml"></span><br><span class="line"></span><span class="number">5.</span><span class="xml">自反：A</span><span class="keyword">^B</span><span class="xml"></span><span class="keyword">^B</span><span class="xml"> = A</span><span class="keyword">^0</span><span class="xml">=A</span><br><span class="line"></span><br><span class="line">根据以上性质:</span><br><span class="line"></span><br><span class="line">A=A</span><span class="keyword">^B</span><span class="xml"></span><br><span class="line">B=A</span><span class="keyword">^B</span><span class="xml"></span><br><span class="line">A=A</span><span class="keyword">^B</span><span class="xml"></span><br><span class="line"></span><br><span class="line">通过以上三步，能实现在程序中交换两个变量的数值的目标。</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>使用异或操作交换字符值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">before:<span class="string">"Hello"</span></span><br><span class="line">after: <span class="string">"olleH"</span></span><br><span class="line"></span><br><span class="line">index: <span class="number">0</span>   <span class="number">1</span>   <span class="number">2</span>   <span class="number">3</span>   <span class="number">4</span></span><br><span class="line"><span class="keyword">char</span> : H   e   l   l   o</span><br><span class="line">ASCII: <span class="number">72</span>  <span class="number">101</span> <span class="number">108</span> <span class="number">108</span> <span class="number">111</span></span><br><span class="line"></span><br><span class="line">以第<span class="number">0</span>个字符和第<span class="number">4</span>个字符交换为例:</span><br><span class="line"></span><br><span class="line">交换前:</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>]=<span class="number">1001000</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">4</span>]=<span class="number">1101111</span></span><br><span class="line"></span><br><span class="line">交换:</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>]=<span class="built_in">array</span>[<span class="number">0</span>]^<span class="built_in">array</span>[<span class="number">4</span>]=<span class="number">0100111</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">4</span>]=<span class="built_in">array</span>[<span class="number">4</span>]^<span class="built_in">array</span>[<span class="number">0</span>]=<span class="number">1001000</span></span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>]=<span class="built_in">array</span>[<span class="number">0</span>]^<span class="built_in">array</span>[<span class="number">4</span>]=<span class="number">1101111</span></span><br><span class="line"></span><br><span class="line">交换后:</span><br><span class="line"><span class="built_in">array</span>[<span class="number">0</span>]=<span class="number">1101111</span>---&gt;<span class="number">111</span>--&gt;o</span><br><span class="line"><span class="built_in">array</span>[<span class="number">4</span>]=<span class="number">1001000</span>---&gt;<span class="number">72</span>---&gt;H</span><br></pre></td></tr></table></figure>
<p><strong>编码实现</strong>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithXor</span><span class="params">(String <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(<span class="built_in">string</span>==null||<span class="built_in">string</span>.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">string</span>;</span><br><span class="line">      <span class="keyword">char</span> [] <span class="built_in">array</span> =<span class="built_in">string</span>.toCharArray();</span><br><span class="line">      <span class="keyword">int</span> length = <span class="built_in">string</span>.length()-<span class="number">1</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;length;i++,length--)&#123;</span><br><span class="line">          <span class="built_in">array</span>[i]^=<span class="built_in">array</span>[length];</span><br><span class="line">          <span class="built_in">array</span>[length]^=<span class="built_in">array</span>[i];</span><br><span class="line">          <span class="built_in">array</span>[i]^=<span class="built_in">array</span>[length];</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> String(<span class="built_in">array</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h5 id="5-_u4F7F_u7528_u9012_u5F52"><a href="#5-_u4F7F_u7528_u9012_u5F52" class="headerlink" title="5.<strong>使用递归</strong>"></a>5.<strong>使用递归</strong></h5><p> 当我们反转字符串的时候，脑海里想的就是从首尾两端依次交换直到到达中间位置。当我们在反转某个字符时，剩下的字符串也是一个反转字符串的过程。这样，我们就能用递归的方法来实现反转字符串的目的。</p>
<p>   <strong>具体思路</strong>是:</p>
<ul>
<li>找出递归结束的临界条件</li>
<li>对针对于临界条件的不同的值做出不同的处理</li>
</ul>
<p><strong>编码实现</strong>： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">strReverseWithRecursive</span><span class="params">(String <span class="built_in">string</span>)</span></span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(<span class="built_in">string</span>==null||<span class="built_in">string</span>.length()==<span class="number">0</span>)<span class="keyword">return</span> <span class="built_in">string</span>;</span><br><span class="line">       <span class="keyword">int</span> length = <span class="built_in">string</span>.length();</span><br><span class="line">       <span class="keyword">if</span>(length==<span class="number">1</span>)&#123;</span><br><span class="line">           <span class="keyword">return</span> <span class="built_in">string</span>;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">           <span class="keyword">return</span>  strReverseWithRecursive(<span class="built_in">string</span>.substring(<span class="number">1</span>))+<span class="built_in">string</span>.charAt(<span class="number">0</span>);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h4&gt;&lt;p&gt;如今无论大小公司，都喜欢出一些算法题来测试面试者的算法功底或者说是计算机功底。而如今Android和Java把很多方法都封装成API了，导致我们写代码往往只是调调API，没有深入了解过一些功能的底层算法实现。因此，研究算法一是能在面试中正确快速的解决算法题，而是能提高我们的编程功底，更好地编写出高效稳健的代码。&lt;/p&gt;
&lt;p&gt;今天，我们研究的是——&lt;strong&gt;反转字符串&lt;/strong&gt;。&lt;/p&gt;
&lt;figure class=&quot;highlight groovy&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;//输入一个字符串，输出它的倒序字符串&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;input:&lt;/span&gt;  Hello&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;output:&lt;/span&gt; olleH&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;h4 id=&quot;u51E0_u79CD_u89E3_u6CD5&quot;&gt;&lt;a href=&quot;#u51E0_u79CD_u89E3_u6CD5&quot; class=&quot;headerlink&quot; title=&quot;几种解法&quot;&gt;&lt;/a&gt;几种解法&lt;/h4&gt;  &lt;figure class=&quot;highlight http&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;string&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt; Hello&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;attribute&quot;&gt;length&lt;/span&gt;: &lt;span class=&quot;string&quot;&gt; 5&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;cpp&quot;&gt;        &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;before: H e l l o&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;after:  o l l e H&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;index             sum&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;: H---&amp;gt;o  &lt;span class=&quot;number&quot;&gt;0&lt;/span&gt;--&amp;gt;&lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;: e---&amp;gt;l  &lt;span class=&quot;number&quot;&gt;1&lt;/span&gt;--&amp;gt;&lt;span class=&quot;number&quot;&gt;3&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;: l---&amp;gt;l  &lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;--&amp;gt;&lt;span class=&quot;number&quot;&gt;2&lt;/span&gt;  &lt;span class=&quot;number&quot;&gt;4&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;...&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;分析字符串反转前后的规律可知:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    两个反转字符串字符的下标之和为字符串长度-&lt;span class=&quot;number&quot;&gt;1.&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="算法" scheme="http://johntsai.work/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Binder:Android进程间的通信机制</title>
    <link href="http://johntsai.work/2016/05/25/Binder-Android%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%9C%BA%E5%88%B6/"/>
    <id>http://johntsai.work/2016/05/25/Binder-Android进程间的通信机制/</id>
    <published>2016-05-25T02:55:24.000Z</published>
    <updated>2016-07-19T06:48:35.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/image/android-logo.png" alt=""></p>
<p>在我们之前的文章<a href="/image/android-at-a-glance/">Android一瞥</a>中，我们介绍了Android的发展历程，解释了它的软件架构以及在Android平台开发应用需要注意什么。在本篇文章中，我将深入讨论<strong>Binder</strong>,复杂并且巨大的Android平台中的核心子系统。我将解释Binder中提供的不同组件,应用进程如何与系统进程通信，以及数据是如何被分享的。</p>
<p>由于智能手机的硬件性能的提升，被称为手中的PC，智能手机开始取代PC。伴随这种趋势，移动操作系统也开始支持多任务和使用多核CPU处理各种多媒体任务。大多数移动操作系统都是基于PC操作系统的。保留了现有PC操作系统的架构，内核稍作了修改以满足移动环境的要求，并添加一些优化的功能。Windows Phone基于微软Windows系统，iOS基于Mac的OS X，Google的Android系统基于Linux内核，三者都是最受欢迎的移动操作系统。<br><a id="more"></a> </p>
<h4 id="u667A_u80FD_u624B_u673A-_u624B_u4E2D_u7684_u7535_u8111_uFF0C_u624B_u4E2D_u7684PC_u64CD_u4F5C_u7CFB_u7EDF"><a href="#u667A_u80FD_u624B_u673A-_u624B_u4E2D_u7684_u7535_u8111_uFF0C_u624B_u4E2D_u7684PC_u64CD_u4F5C_u7CFB_u7EDF" class="headerlink" title="智能手机-手中的电脑，手中的PC操作系统"></a>智能手机-手中的电脑，手中的PC操作系统</h4><p>如果你有类似这样的疑问，</p>
<blockquote>
<p>如果PC的操作系统被植入到智能手机中，什么将会被修改，怎样以及为什么修改？</p>
</blockquote>
<p>开源的Android平台能提供给你非常完美的答案。Android平台包含了最新的软件技术，它通过他的开发者社区提供了大量的信息并且允许用户直接修改它的开源代码。</p>
<p>Android继承了Linux内核非常强大的底层系统，如内存管理，多任务以及文件管理。另外，它还降低了开发门槛，通过提供适用于基于Dalvik虚拟机的Java应用的各种各样的开发工具。虽然底层系统是用C++语言实现的，它们是非常高效的代码。实际上，Android开发者说Android系统的一个优点就是相比于其他系统，他们使用的是C++实现的。</p>
<p>因此，Android是一个包括多种技术的系统，如Linux内核，C++，Java，Dalvik虚拟机等。</p>
<p><img src="/image/typical-schematic-of-android_structure.png" alt=""></p>
<h4 id="u4E0D_u7BA1_u600E_u6837_uFF0C_u5B83_u90FD_u662FLinux_u8FDB_u7A0B"><a href="#u4E0D_u7BA1_u600E_u6837_uFF0C_u5B83_u90FD_u662FLinux_u8FDB_u7A0B" class="headerlink" title="不管怎样，它都是Linux进程"></a>不管怎样，它都是Linux进程</h4><p>Android提供了进程单元组件模型。换句话说，为应用提供相机功能的系统服务，负责屏幕显示的系统服务，所有这样的Android组件最终都是以Linux进程形式展示的。</p>
<p><img src="/image/process_management_of_linux-kernel.png" alt=""></p>
<p>因为Android运行在基于Linux内存，进程姐文件管理之上，系统服务也会因保护被Linux进程隔离开来。系统进程是使用Java代码和C++ Native代码编写的，所以服务运行在Dalvik虚拟机上，例如WiFi，定位和Activity服务等。</p>
<p>为了支持移动设备例如智能手机，Android系统所有默认的系统功能都被以服务进程(server process)的类型提供。换句话说，为了使用例如<code>SurfaceFlinger</code>或<code>AudioFlinger</code>这样的功能，作为一个运行在用户模式下的独立进程的请求应该被发出。</p>
<p><img src="/image/android_system_services_and_applications_run_by_linux_process.png" alt=""></p>
<p>例如，当我开发的应用调用Android SDK的API来获得位置信息时，应用发送请求给提供位置服务的内部Linux进程，然后获得回复。同样地，当相机被使用时，与相机服务进行交互。</p>
<p><img src="/image/application_process_with_call_locations_service_and_camera_service.png" alt=""></p>
<p>由于所有系统服务都被作为服务进程(server process),一种进程间发送和回复请求的机制是必要的。在Android中，被称为Binder机制。Android通过Binder使用其他进程提供的方法。</p>
<p><img src="/image/binder_android_communication_infrastructure_between_processes.png" alt=""></p>
<p>然后，<em>为什么开发一种新的机制，而不使用Linux提供的跨进程通信机制(IPC)，例如Sockets和Pipes?</em> 这主要是因为性能，正如我们之前讨论的，Android的所有系统功能都被以服务进程的形式提供，所以一个最优的跨进程通信方法是必要的，而Binder因此而诞生。Binder引用被所有进程共享的内核内存来降低由于内存拷贝造成的开销。另外，它提供了用C++编写的远端程序调用(RPC)框架。</p>
<p>系统方法都被以服务进程的形式提供，请求和回复都通过Binder机制。你会问，</p>
<blockquote>
<p>Android系统架构会因此有什么好处?</p>
</blockquote>
<ul>
<li><strong>易于拓展和移除功能</strong> 增加新的系统服务或移除现有的功能变得很容易。</li>
<li><strong>易于测试</strong> 测试被限制在组件单元级别，所以不可能测试整个服务，因此有着更严格的测试。</li>
<li><strong>易于通信(port)</strong> 与新的处理器通信需要一些改变，提供了通信所需要的工具。</li>
<li><strong>支持分布式系统</strong> 进程间通信是基于Binder的，因此它保证了组件间位置的透明。</li>
</ul>
<p>这些好处和微核架构的操作系统的优点很相似。</p>
<p>让我们进一步讨论Binder。</p>
<h4 id="u7ED1_u5B9A_u6240_u6709_u529F_u80FD_u7684Binder"><a href="#u7ED1_u5B9A_u6240_u6709_u529F_u80FD_u7684Binder" class="headerlink" title="绑定所有功能的Binder"></a>绑定所有功能的Binder</h4><p>Binder机制源于一个简单的想法。<strong>“<em>让（进程间的）请求和回复被写进所有进程都能共享(share)到的区域，让每个进程都指向内存地址。</em>”</strong>因此内核区域正好满足这些要求。</p>
<p><img src="/image/kernel_space_shared_by_all_processes_1.png" alt=""></p>
<p>Binder驱动用来使用内核区域，它的作用是转换内存地址，每个进程将内核区域的内存地址映射到引用。</p>
<p><img src="/image/binder_driver_configuration.png" alt=""></p>
<p>Binder驱动能被<code>ioctl()</code>系统方法使用，ioctl方法是标准的Linux方法。这种机制被称为Binder IPC。</p>
<p><img src="/image/transfer_structure_of_user_data_between_processes_through_binder_driver.png" alt=""></p>
<p>这里有一种C++框架，处理使用Binder IPC传输的数据，发起远端程序调用(RPC)。通常用于创建系统服务。然后，一个进程能使用其他进程的方法就像它自己的一样。</p>
<p><img src="/image/c++framefork_that_transltes_data_translated_to_rpc_through_binder_driver.png" alt=""></p>
<h4 id="u7ED3_u8BBA"><a href="#u7ED3_u8BBA" class="headerlink" title="结论"></a>结论</h4><p>在这边简短的文章中，我尝试在Android大量的技术背后介绍一些简单的知识。我希望对你理解Android系统有所帮助。</p>
<p>总之，Binder是Android系统的基础。我们主要学习了Binder的三个组件:<em>驱动(Driver)</em>、<em>IPC</em>和<em>RPC</em>。</p>
<hr>
<p>本文翻译自<a href="http://www.cubrid.org/blog/dev-platform/binder-communication-mechanism-of-android-processes/" target="_blank" rel="external">Binder: Communication Mechanism of Android Processes</a>,版权归原作者所有，译文版权归本人所有。</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/image/android-logo.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;在我们之前的文章&lt;a href=&quot;/image/android-at-a-glance/&quot;&gt;Android一瞥&lt;/a&gt;中，我们介绍了Android的发展历程，解释了它的软件架构以及在Android平台开发应用需要注意什么。在本篇文章中，我将深入讨论&lt;strong&gt;Binder&lt;/strong&gt;,复杂并且巨大的Android平台中的核心子系统。我将解释Binder中提供的不同组件,应用进程如何与系统进程通信，以及数据是如何被分享的。&lt;/p&gt;
&lt;p&gt;由于智能手机的硬件性能的提升，被称为手中的PC，智能手机开始取代PC。伴随这种趋势，移动操作系统也开始支持多任务和使用多核CPU处理各种多媒体任务。大多数移动操作系统都是基于PC操作系统的。保留了现有PC操作系统的架构，内核稍作了修改以满足移动环境的要求，并添加一些优化的功能。Windows Phone基于微软Windows系统，iOS基于Mac的OS X，Google的Android系统基于Linux内核，三者都是最受欢迎的移动操作系统。&lt;br&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>Android开发艺术探索学习笔记——IPC机制（一）</title>
    <link href="http://johntsai.work/2016/05/23/Android%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94IPC%E6%9C%BA%E5%88%B6%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://johntsai.work/2016/05/23/Android开发艺术探索学习笔记——IPC机制（一）/</id>
    <published>2016-05-23T08:30:00.000Z</published>
    <updated>2016-05-23T09:00:58.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="IPC_u673A_u5236"><a href="#IPC_u673A_u5236" class="headerlink" title="IPC机制"></a>IPC机制</h3><p>定义：Inter-Process Communication(IPC),进程间通信或跨进程通信，指<strong>两个进程之间</strong>进行数据交换的过程。</p>
<blockquote>
<p>线程和进程:</p>
<p>线程:CPU调度的最小单元，一种有限的系统资源。</p>
<p>进程：一个执行单元，在PC或手机中指一个程序或应用。</p>
<p>一个进程可以包含多个线程。</p>
</blockquote>
<h3 id="Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F"><a href="#Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F" class="headerlink" title="Android中的多进程模式"></a>Android中的多进程模式</h3><h4 id="u5F00_u542F_u591A_u8FDB_u7A0B_u6A21_u5F0F"><a href="#u5F00_u542F_u591A_u8FDB_u7A0B_u6A21_u5F0F" class="headerlink" title="开启多进程模式"></a>开启多进程模式</h4><p>方法：</p>
<ul>
<li>在AndroidManifest文件中为四大组件指定<code>android:process</code>属性。</li>
<li>通过JNI在native层fork一个新的进程<em>（属特殊情况，一般不这么使用）</em></li>
</ul>
<blockquote>
<p>查看Android系统当前线程的方法：</p>
<ul>
<li>1.在Android Studio的Android Device Monitor中查看</li>
<li>2.通过<code>adb shell ps [| grep 进程名]</code>来查看</li>
</ul>
</blockquote>
<a id="more"></a> 
<h3 id="u591A_u8FDB_u7A0B_u6A21_u5F0F_u7684_u8FD0_u884C_u673A_u5236"><a href="#u591A_u8FDB_u7A0B_u6A21_u5F0F_u7684_u8FD0_u884C_u673A_u5236" class="headerlink" title="多进程模式的运行机制"></a>多进程模式的运行机制</h3><p>Android为每个应用分配一个独立的虚拟机，或者说是为每个进程分配一个独立的虚拟机。</p>
<blockquote>
<p>Java Runtime类，允许Java应用与它们运行时环境进行交互。通过getRuntime()方法获取该类的单例实例。</p>
</blockquote>
<p>下面通过一个例子来深入学习下：<br>有两个Activity，MainActivity和SecondActivity，为SecondActivity指定<code>android:process</code>属性为<code>:remote</code><br><img src="http://7xr1jz.com1.z0.glb.clouddn.com/QQ20160523-1%402x.png" alt=""><br>新建一个UserManager类，类中有一个public的静态成员变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserManager</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> sUserId = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在MainActivity中将<code>sUserId</code>重新赋值为2并打印，然后启动SecondActivity并打印</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MainActivity的onCreate方法</span></span><br><span class="line"> UserManager.sUserId = <span class="number">2</span>;</span><br><span class="line">       Log.d(TAG,<span class="string">"MainActivity userId:"</span>+UserManager.sUserId +</span><br><span class="line">               Runtime.getRuntime().toString()</span><br><span class="line">       );</span><br><span class="line">       button = (Button) findViewById(R.id.button);</span><br><span class="line">       button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">           <span class="annotation">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">               startActivity(<span class="keyword">new</span> Intent(MainActivity.<span class="keyword">this</span>,SecondActivity.class));</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">       </span><br><span class="line"> <span class="comment">//SecondActivity的onCreate方法</span></span><br><span class="line">   Log.d(TAG,<span class="string">"SecondActivity userId:"</span>+UserManager.sUserId</span><br><span class="line">               +  Runtime.getRuntime().toString()</span><br><span class="line">       );</span><br></pre></td></tr></table></figure>
<p> 打印出的日志:<br> <img src="http://7xr1jz.com1.z0.glb.clouddn.com/androidQQ20160523-2%402x.png" alt=""></p>
<p> 可以看出两个不同的进程对应两个不同的虚拟机，在内存分配上有着不同的地址空间，这就导致不同虚拟机访问同一个对象会产生多份副本。</p>
<p> <img src="http://7xr1jz.com1.z0.glb.clouddn.com/androidQQ20160523-3%402x.png" alt=""></p>
<blockquote>
<p>在进程<code>xyz.johntsai.ipcdemo</code>和进程<code>xyz.johntsai.ipcdemo:remote</code>中都存在一个<code>UserManager类</code>，在一个进程中修改sUserId的值只会影响当前进程，对其他进程不会造成影响。</p>
</blockquote>
<p> 使用<strong>多进程</strong>会造成如下几方面的问题：</p>
<ul>
<li>1.静态成员和单例模式完全失效</li>
<li>2.线程同步机制完全失效</li>
<li>3.SharedPreferences的可靠性下降（SharedPreferences底层是通过读写XML实现的，并发写可能会出问题）</li>
<li><p>4.Application会多次创建</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> public <span class="class"><span class="keyword">class</span> <span class="title">DemoApplication</span> <span class="keyword"><span class="keyword">extends</span></span> <span class="title">Application</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    public void onCreate() &#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="type">String</span> processName = getProcessName(getApplicationContext(), <span class="type">Process</span>.myPid());</span><br><span class="line">        <span class="type">Log</span>.d(<span class="string">"TAG"</span>,<span class="string">"process name:"</span>+processName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 获取进程名字</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    public static <span class="type">String</span> getProcessName(<span class="type">Context</span> context,int id)&#123;</span><br><span class="line">        <span class="type">ActivityManager</span> am = (<span class="type">ActivityManager</span>) context.getSystemService(<span class="type">ACTIVITY_SERVICE</span>);</span><br><span class="line">        <span class="type">List</span>&lt;<span class="type">ActivityManager</span>.<span class="type">RunningAppProcessInfo</span>&gt; runningAppProcesses = am.getRunningAppProcesses();</span><br><span class="line">        <span class="type">Iterator</span>&lt;<span class="type">ActivityManager</span>.<span class="type">RunningAppProcessInfo</span>&gt; i = runningAppProcesses.iterator();</span><br><span class="line">        <span class="keyword">while</span> (i.hasNext())&#123;</span><br><span class="line">            <span class="type">ActivityManager</span>.<span class="type">RunningAppProcessInfo</span> info = i.next();</span><br><span class="line">            <span class="keyword">if</span>(info.pid==id)&#123;</span><br><span class="line">                <span class="keyword">return</span> info.processName;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p> 运行结果：<br> <img src="http://7xr1jz.com1.z0.glb.clouddn.com/androidQQ20160523-4%402x.png" alt=""></p>
<blockquote>
<p>通过日志可以看出Application的onCreate方法执行了两次，并且两次的进程名不一样，他们的进程名与我们为Activity指定的一致。</p>
</blockquote>
<p> 在多进程模式下，<strong>不同进程的组件拥有独立的虚拟机，Application和内存空间</strong>。</p>
<p> 跨进程通信方式：</p>
<ul>
<li>Intent</li>
<li>共享文件</li>
<li>SharedPreferences</li>
<li>基于Binder的Messager</li>
<li>AIDL</li>
<li>Socket</li>
</ul>
<h3 id="IPC_u57FA_u7840_u6982_u5FF5"><a href="#IPC_u57FA_u7840_u6982_u5FF5" class="headerlink" title="IPC基础概念"></a>IPC基础概念</h3><h4 id="Serializable_u63A5_u53E3"><a href="#Serializable_u63A5_u53E3" class="headerlink" title="Serializable接口"></a>Serializable接口</h4> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Serializable是Java提供的一个序列化接口，查看源码可知它是一个空接口。为对象提供标准的序列化和反序列化操作。</p>
<p> <a href="http://stackoverflow.com/questions/441196/why-java-needs-serializable-interface" target="_blank" rel="external">为什么Java中需要Serializable接口</a></p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">3087127068404846418L</span>;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">private</span> String name;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> id;</span><br><span class="line">       <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">       ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Serializable序列化过程和反序列化过程</p>
 <figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setName(<span class="string">"John"</span>);</span><br><span class="line">user.setAge(<span class="number">21</span>);</span><br><span class="line">user.setId(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">Log.d(TAG,<span class="string">"before:"</span>+user.toString());</span><br><span class="line"></span><br><span class="line"><span class="keyword">File</span> <span class="keyword">file</span> = <span class="keyword">new</span> <span class="keyword">File</span>(Environment.getExternalStorageDirectory(),<span class="string">"test.txt"</span>);</span><br><span class="line"><span class="comment">//序列化过程</span></span><br><span class="line">ObjectOutputStream oos = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    oos = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="keyword">file</span>));</span><br><span class="line">    oos.writeObject(user);</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (oos != <span class="keyword">null</span>) &#123;</span><br><span class="line">            oos.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反序列化过程</span></span><br><span class="line">ObjectInputStream ois = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ois = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="keyword">file</span>));</span><br><span class="line">    User readUser = (User)ois.readObject();</span><br><span class="line">    Log.d(TAG,<span class="string">"after:"</span>+readUser.toString()</span><br><span class="line">      +<span class="string">"\nreadUser equal with user:"</span>+user.equals(readUser)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException | ClassNotFoundException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (ois != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ois.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 运行结果：<br> <img src="http://7xr1jz.com1.z0.glb.clouddn.com/androidQQ20160523-5%402x.png" alt=""></p>
<p> 通过运行结果，我们可以看出两个对象的内容完全一样，但两者并不是同一对象。</p>
<h4 id="Parcelable_u63A5_u53E3"><a href="#Parcelable_u63A5_u53E3" class="headerlink" title="Parcelable接口"></a>Parcelable接口</h4><p> 实现Parcelable接口，类的对象可实现序列化并通过Intent和Binder传递。</p>
 <figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserImlParcelable</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> &#123;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="typename">int</span> id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="typename">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> UserImlParcelable(<span class="typename">int</span> id,String name,<span class="typename">int</span> age)&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="typename">int</span> describeContents() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="typename">void</span> writeToParcel(Parcel dest, <span class="typename">int</span> flags) &#123;</span><br><span class="line">        dest.writeInt(id);</span><br><span class="line">        dest.writeString(name);</span><br><span class="line">        dest.writeInt(age);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">protected</span> UserImlParcelable(Parcel <span class="keyword">in</span>) &#123;</span><br><span class="line">        id = <span class="keyword">in</span>.readInt();</span><br><span class="line">        name = <span class="keyword">in</span>.readString();</span><br><span class="line">        age = <span class="keyword">in</span>.readInt();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Creator&lt;UserImlParcelable&gt; CREATOR = <span class="keyword">new</span> Creator&lt;UserImlParcelable&gt;() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> UserImlParcelable createFromParcel(Parcel <span class="keyword">in</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserImlParcelable(<span class="keyword">in</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> UserImlParcelable[] newArray(<span class="typename">int</span> size) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> UserImlParcelable[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String toString() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"UserImlParcelable&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", age="</span> + age +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>Parcelable和Serializable的区别：</strong></p>
<ul>
<li>Serializable是Java提供的序列化接口，使用简单，只需实现接口，Java会在特定情况下自动序列化类的对象。</li>
<li>Parcelable是Android提供的序列化接口，使用起来稍微复杂些，但是效率高，速度快。</li>
<li>Serializable主要用在将对象序列化到存储设备中或通过网络传输。</li>
<li>Parcelable主要用在内存序列化上，如用在Binder和AIDL中传输数据。</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;IPC_u673A_u5236&quot;&gt;&lt;a href=&quot;#IPC_u673A_u5236&quot; class=&quot;headerlink&quot; title=&quot;IPC机制&quot;&gt;&lt;/a&gt;IPC机制&lt;/h3&gt;&lt;p&gt;定义：Inter-Process Communication(IPC),进程间通信或跨进程通信，指&lt;strong&gt;两个进程之间&lt;/strong&gt;进行数据交换的过程。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;线程和进程:&lt;/p&gt;
&lt;p&gt;线程:CPU调度的最小单元，一种有限的系统资源。&lt;/p&gt;
&lt;p&gt;进程：一个执行单元，在PC或手机中指一个程序或应用。&lt;/p&gt;
&lt;p&gt;一个进程可以包含多个线程。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F&quot;&gt;&lt;a href=&quot;#Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F&quot; class=&quot;headerlink&quot; title=&quot;Android中的多进程模式&quot;&gt;&lt;/a&gt;Android中的多进程模式&lt;/h3&gt;&lt;h4 id=&quot;u5F00_u542F_u591A_u8FDB_u7A0B_u6A21_u5F0F&quot;&gt;&lt;a href=&quot;#u5F00_u542F_u591A_u8FDB_u7A0B_u6A21_u5F0F&quot; class=&quot;headerlink&quot; title=&quot;开启多进程模式&quot;&gt;&lt;/a&gt;开启多进程模式&lt;/h4&gt;&lt;p&gt;方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在AndroidManifest文件中为四大组件指定&lt;code&gt;android:process&lt;/code&gt;属性。&lt;/li&gt;
&lt;li&gt;通过JNI在native层fork一个新的进程&lt;em&gt;（属特殊情况，一般不这么使用）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;查看Android系统当前线程的方法：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.在Android Studio的Android Device Monitor中查看&lt;/li&gt;
&lt;li&gt;2.通过&lt;code&gt;adb shell ps [| grep 进程名]&lt;/code&gt;来查看&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
  </entry>
  
  <entry>
    <title>为Android设备设置Charles代理</title>
    <link href="http://johntsai.work/2015/12/15/Android%E6%8A%93%E5%8C%85%E8%AE%BE%E7%BD%AECharles%E4%BB%A3%E7%90%86/"/>
    <id>http://johntsai.work/2015/12/15/Android抓包设置Charles代理/</id>
    <published>2015-12-15T04:41:24.000Z</published>
    <updated>2016-03-16T02:44:49.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p><a href="https://www.charlesproxy.com/" target="_blank" rel="external">Charles</a>是Mac平台上一款非常优秀的HTTP网络抓包工具。</p>
<h1 id="Android_u6293_u5305_u8BBE_u7F6ECharles_u4EE3_u7406"><a href="#Android_u6293_u5305_u8BBE_u7F6ECharles_u4EE3_u7406" class="headerlink" title="Android抓包设置Charles代理"></a>Android抓包设置Charles代理</h1><h2 id="u4E3AGenymotion_u8BBE_u7F6E_u4EE3_u7406"><a href="#u4E3AGenymotion_u8BBE_u7F6E_u4EE3_u7406" class="headerlink" title="为Genymotion设置代理"></a>为Genymotion设置代理</h2><ul>
<li>1依次打开genymotion的设置–&gt;WLAN</li>
<li>2长按WirelessSSID，选择高级选项,将代理设置为手动</li>
<li>3分别将代理服务器设为10.0.3.2（genymotion在本地网络环境下的IP），将端口号设置为8888</li>
<li>4.保存即可</li>
</ul>
<a id="more"></a> 
<p><img src="http://ww4.sinaimg.cn/mw690/8942f980gw1ez0anh8fqhj20hi0tdq5l.jpg" alt=""></p>
<h2 id="u4E3AAndroid_u771F_u673A_u8BBE_u7F6E_u4EE3_u7406"><a href="#u4E3AAndroid_u771F_u673A_u8BBE_u7F6E_u4EE3_u7406" class="headerlink" title="为Android真机设置代理"></a>为Android真机设置代理</h2><p>Mac查看本机IP地址：</p>
<ul>
<li>在终端中输入<code>ifconfig</code></li>
<li>系统偏好设置-&gt;网络-&gt;高级-&gt;TCP/IP</li>
</ul>
<p>具体步骤和Genymotion的类似，只是将代理服务器地址设为本机IP地址。</p>
<blockquote>
<p>注意当真机请求时，Charles软件会弹出对话框，选择allow即可。 </p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;u524D_u8A00&quot;&gt;&lt;a href=&quot;#u524D_u8A00&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;&lt;a href=&quot;https://www.charlesproxy.com/&quot;&gt;Charles&lt;/a&gt;是Mac平台上一款非常优秀的HTTP网络抓包工具。&lt;/p&gt;
&lt;h1 id=&quot;Android_u6293_u5305_u8BBE_u7F6ECharles_u4EE3_u7406&quot;&gt;&lt;a href=&quot;#Android_u6293_u5305_u8BBE_u7F6ECharles_u4EE3_u7406&quot; class=&quot;headerlink&quot; title=&quot;Android抓包设置Charles代理&quot;&gt;&lt;/a&gt;Android抓包设置Charles代理&lt;/h1&gt;&lt;h2 id=&quot;u4E3AGenymotion_u8BBE_u7F6E_u4EE3_u7406&quot;&gt;&lt;a href=&quot;#u4E3AGenymotion_u8BBE_u7F6E_u4EE3_u7406&quot; class=&quot;headerlink&quot; title=&quot;为Genymotion设置代理&quot;&gt;&lt;/a&gt;为Genymotion设置代理&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;1依次打开genymotion的设置–&amp;gt;WLAN&lt;/li&gt;
&lt;li&gt;2长按WirelessSSID，选择高级选项,将代理设置为手动&lt;/li&gt;
&lt;li&gt;3分别将代理服务器设为10.0.3.2（genymotion在本地网络环境下的IP），将端口号设置为8888&lt;/li&gt;
&lt;li&gt;4.保存即可&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
    
      <category term="Android" scheme="http://johntsai.work/tags/Android/"/>
    
  </entry>
  
</feed>
