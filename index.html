<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="No pain No gain"><title>JohnTsai | 万物之中，希望最美，最美之物，永不凋零.</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">JohnTsai</h1><a id="logo" href="/.">JohnTsai</a><p class="description">万物之中，希望最美，最美之物，永不凋零.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首頁</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="/about/"><i class="fa fa-user"> 關於</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h2 class="post-title"><a href="/2017/03/15/CSS_Learn_Notes_2/">CSS学习笔记（二）——样式</a></h2><div class="post-meta">2017-03-15</div><div class="post-content"><!-- START doctoc generated TOC please keep comment here to allow auto update -->
<!-- DON'T EDIT THIS SECTION, INSTEAD RE-RUN doctoc TO UPDATE -->
<ul></div><p class="readmore"><a href="/2017/03/15/CSS_Learn_Notes_2/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2017/03/15/CSS_Learn_Notes_1/">CSS学习笔记</a></h2><div class="post-meta">2017-03-15</div><div class="post-content"><h3 id="u4EC0_u4E48_u662FCSS"><a href="#u4EC0_u4E48_u662FCSS" class="headerlink" title="什么是CSS"></a>什么是CSS</h3><p>CSS指层叠样式表(<strong>C</strong>ascading <strong>S</strong>tyle <strong>S</strong>heets)</p></div><p class="readmore"><a href="/2017/03/15/CSS_Learn_Notes_1/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/07/27/理解RxJava(四)Reactive Android/">理解RxJava:(四)Reactive Android</a></h2><div class="post-meta">2016-07-27</div><div class="post-content"><p>在前三部分，我在通用层面介绍了RxJava的工作原理。但是作为一个Android开发者，如何在工作中使用它呢?下面是一些给Android开发者的RxJava的具体应用。</p>
<h2 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h2><p><a href="https://github.com/ReactiveX/RxAndroid">RxAndroid</a>是RxJava在Android开发中的拓展。它包含能节省我们大量时间的特殊bindings。</p>
<p>首先，其中有<code>AndroidSchedulers</code>，它能提供专门为Android线程系统提供的schedulers。需要在UI线程运行代码?没问题——只需要使用<code>AndroidSchedulers.mainThread()</code>方法即可:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">retrofitService</span><span class="class">.getImage</span>(<span class="tag">url</span>)</span><br><span class="line">    <span class="class">.subscribeOn</span>(<span class="tag">Schedulers</span><span class="class">.io</span>())</span><br><span class="line">    <span class="class">.observeOn</span>(<span class="tag">AndroidSchedulers</span><span class="class">.mainThread</span>())</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">bitmap</span> <span class="tag">-</span>&gt; <span class="tag">myImageView</span><span class="class">.setImageBitmap</span>(<span class="tag">bitmap</span>));</span><br></pre></td></tr></table></figure>
<p>如果你拿到的是<code>Handler</code>，可以通过<code>HandlerThreadScheduler</code>创建一个scheduler绑定在Handler上。</p>
<p>接下来介绍的是<code>AndroidObservable</code>，它能提供很多在Android生命周期中的特色功能。<code>bindActivity()</code>和<code>bindFragment()</code>方法能停止发出items，在<code>Activity</code>或<code>Fragment</code>结束的时候。另外会自动为订阅使用<code>AndroidSchedulers.mainThread()</code>。（因此你不需要在Activity或Fragment无效的时候来改变状态）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">AndroidObservable</span><span class="class">.bindActivity</span>(<span class="tag">this</span>, <span class="tag">retrofitService</span><span class="class">.getImage</span>(<span class="tag">url</span>))</span><br><span class="line">    <span class="class">.subscribeOn</span>(<span class="tag">Schedulers</span><span class="class">.io</span>())</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">bitmap</span> <span class="tag">-</span>&gt; <span class="tag">myImageView</span><span class="class">.setImageBitmap</span>(<span class="tag">bitmap</span>));</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2016/07/27/理解RxJava(四)Reactive Android/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/07/26/理解RxJava(三)RxJava的优点/">理解RxJava:(三)RxJava的优点</a></h2><div class="post-meta">2016-07-26</div><div class="post-content"><p>在第一部分，讲解了RxJava的基本结构。在第二部分，展示了operators的强大之处。但是你们可能仍然没有被说服，也没有足够的理由信服。下面是一些能让你信服的RxJava框架的优点。</p>
<h2 id="u9519_u8BEF_u5904_u7406"><a href="#u9519_u8BEF_u5904_u7406" class="headerlink" title="错误处理"></a>错误处理</h2><p>截至当前，我们一直都忽略<code>onComplete()</code>和<code>onError()</code>方法。它们标志着<code>Observable</code>停止发出items以及原因（不管是成功地完成或是不可恢复的错误）。</p>
<p>我们最初的<code>Subscriber</code>有能力监听<code>onComplete()</code>和<code>onError()</code>事件。动手实现如下所示：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Observable.just(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .<span class="built_in">map</span>(s -&gt; potentialException(s))</span><br><span class="line">    .<span class="built_in">map</span>(s -&gt; anotherPotentialException(s))</span><br><span class="line">    .subscribe(<span class="keyword">new</span> Subscriber&lt;<span class="keyword">String</span>&gt;() &#123;</span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onNext(<span class="keyword">String</span> s) &#123; System.out.<span class="built_in">println</span>(s); &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onCompleted() &#123; System.out.<span class="built_in">println</span>(<span class="string">"Completed!"</span>); &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">void</span> onError(Throwable e) &#123; System.out.<span class="built_in">println</span>(<span class="string">"Ouch!"</span>); &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>假设<code>potentialException()</code>和<code>anotherPotentialException()</code>都能抛出异常。每个<code>Observable</code>都以调用<code>onCompleted()``onError()</code>方法结束。正因为这样， 程序的输出要么是<code>Completed!</code>，要么是<code>Ouch!</code>(因为异常的抛出)<br></div><p class="readmore"><a href="/2016/07/26/理解RxJava(三)RxJava的优点/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/07/23/理解RxJava(二)Operator，Operator/">理解RxJava:(二)Operator，Operator</a></h2><div class="post-meta">2016-07-23</div><div class="post-content"><p>在<a href="https://johntsai.xyz/2016/07/22/%E7%90%86%E8%A7%A3RxJava%28%E4%B8%80%29%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">第一部分</a>，我讲解了RxJava的基本结构，也介绍了<code>map()</code>操作。然而，我能理解你仍旧不会选择使用Rxjava——你仍然还有很多东西没有学到。但是这个情况将很快得到改变。Rxjava一大部分的能力是因为其中的operators。</p>
<p>让我们通过一个例子来向你们介绍更多的operators。</p>
<h2 id="u521D_u59CB"><a href="#u521D_u59CB" class="headerlink" title="初始"></a>初始</h2><p>假设我有一个这样的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回一个基于文本查询网站链接的列表</span></span><br><span class="line">Observable&lt;List&lt;String&gt;&gt; query(String text);</span><br></pre></td></tr></table></figure>
<p>我想要构建一个搜索文本和显示结果的强健系统。基于上篇文章我们学到的，以下是我们马上想到的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">query(<span class="string">"Hello, world!"</span>)</span><br><span class="line">    .subscribe(urls -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (String url : urls) &#123;</span><br><span class="line">            System.out.println(url);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<p>这个答案让人非常不满意，因为失去了转换数据流的能力。如果我想要修改每个URL，只能在每个<code>Subscriber</code>里面修改。这就违背了使用<code>map()</code>操作的初衷。</p>
<p>我可以为ulrs-&gt;urls创建一个<code>map()</code>,但是每个<code>map()</code>的内部都有一个for－each循环。哎哟。<br></div><p class="readmore"><a href="/2016/07/23/理解RxJava(二)Operator，Operator/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/07/22/理解RxJava(一)基础知识/">理解RxJava:(一)基础知识</a></h2><div class="post-meta">2016-07-22</div><div class="post-content"><p>本文翻译自<a href="http://blog.danlew.net/2014/09/15/grokking-rxjava-part-1/">Grokking RxJava, Part 1: The Basics</a>,著作权归原作者<a href="https://twitter.com/danlew42">danlew</a>所有。译文由<a href="https://www.github.com/JohnTsaiAndroid">JohnTsai</a>翻译。转载请注明出处，并保留此段声明。</p>
<p><a href="https://github.com/ReactiveX/RxJava">RxJava</a>这些天成为了Android开发者关注的新热点。唯一的问题是它在你刚接触时难以理解。当你习惯了命令式编程，函数响应式编程就变得难以理解。但是一旦你理解了它，它就变得很棒了。</p>
<p>我在这试着给你们带来不一样的RxJava。这一系列四篇文章的目标是带你们入门。我不会也不能讲解所有的东西。我只是想让你们对RxJava以及它的工作原理感兴趣。</p>
<h2 id="u57FA_u7840_u77E5_u8BC6"><a href="#u57FA_u7840_u77E5_u8BC6" class="headerlink" title="基础知识"></a>基础知识</h2><p>响应式代码的基本构成部分是<code>Observables</code>和<code>Subscribers</code>(<em>译者注：技术名词很难找到合适的中文翻译，所以维持原文不被翻译</em>)。<code>Observable</code>发出items，<code>Subscriber</code>消费这些items。</p>
<p>items如何被消费有一套规则。<code>Observable</code>发出任意数量的items（包括0个items），要么以成功完成终止，要么以发生错误终止。对于<code>Observable</code>的每个<code>Subscriber</code>,<code>Observable</code>调用<code>Subscriber.onNext()</code>方法任意次，然后调用<code>Subscriber.onComplete()</code>方法或<code>Subscriber.onError()</code>方法。</p>
<p>这看起来和我们用的<a href="https://en.wikipedia.org/wiki/Observer_pattern">观察者模式</a>类似，但在一个关键地方不同——<code>Observables</code>在有人明确地订阅它之后才会开始发出items。换句话说，没有人去订阅，就不会发出订阅事件（<em>译者注：引申自<a href="https://en.wikipedia.org/wiki/If_a_tree_falls_in_a_forest">If a tree falls in a forest</a></em>）。</p></div><p class="readmore"><a href="/2016/07/22/理解RxJava(一)基础知识/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/07/21/Android问题小结/">Android问题小结</a></h2><div class="post-meta">2016-07-21</div><div class="post-content"><h4 id="1-Gradle_u7F16_u8BD1_u62A5_u9519_u5982_u4E0B_uFF1A"><a href="#1-Gradle_u7F16_u8BD1_u62A5_u9519_u5982_u4E0B_uFF1A" class="headerlink" title="1.Gradle编译报错如下："></a>1.Gradle编译报错如下：</h4><p><code>Failed to resolve: XXXX. Show in File, Show in Project Structure dialog</code></p></div><p class="readmore"><a href="/2016/07/21/Android问题小结/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/07/19/Android如何从堆栈中还原ProGuard混淆后的代码/">Android:如何从堆栈中还原ProGuard混淆后的代码</a></h2><div class="post-meta">2016-07-19</div><div class="post-content"><p>本文翻译自<a href="http://simplyadvanced.net/blog/android-how-to-decode-proguards-obfuscated-code-from-stack-trace/">Android: How To Decode ProGuard’s Obfuscated Code From Stack Trace</a></p>
<p>本篇文章是写给那些在他们的应用中使用<a href="http://developer.android.com/tools/help/proguard.html">ProGuard</a>并且需要从堆栈信息中进行调试的Android开发者。这是一种非常简单就将混淆的错误信息转化为可读的方法。</p>
<h3 id="u8FD8_u539F_u524D"><a href="#u8FD8_u539F_u524D" class="headerlink" title="还原前"></a>还原前</h3><p>以下是ProGuard混淆过的堆栈信息:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java<span class="class">.lang</span><span class="class">.NullPointerException</span></span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.be</span><span class="class">.u</span>(Unknown Source)</span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.at</span><span class="class">.v</span>(Unknown Source)</span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.at</span><span class="class">.d</span>(Unknown Source)</span><br><span class="line">at net<span class="class">.simplyadvanced</span><span class="class">.ltediscovery</span><span class="class">.av</span><span class="class">.onReceive</span>(Unknown Source)</span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2016/07/19/Android如何从堆栈中还原ProGuard混淆后的代码/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/06/22/深入浅出经典面试题之——反转字符串/">深入浅出经典面试题之——反转字符串</a></h2><div class="post-meta">2016-06-22</div><div class="post-content"><h4 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h4><p>如今无论大小公司，都喜欢出一些算法题来测试面试者的算法功底或者说是计算机功底。而如今Android和Java把很多方法都封装成API了，导致我们写代码往往只是调调API，没有深入了解过一些功能的底层算法实现。因此，研究算法一是能在面试中正确快速的解决算法题，而是能提高我们的编程功底，更好地编写出高效稳健的代码。</p>
<p>今天，我们研究的是——<strong>反转字符串</strong>。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//输入一个字符串，输出它的倒序字符串</span></span><br><span class="line"><span class="string">input:</span>  Hello</span><br><span class="line"><span class="string">output:</span> olleH</span><br></pre></td></tr></table></figure>
<h4 id="u51E0_u79CD_u89E3_u6CD5"><a href="#u51E0_u79CD_u89E3_u6CD5" class="headerlink" title="几种解法"></a>几种解法</h4>  <figure class="highlight http"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">string</span>: <span class="string"> Hello</span></span><br><span class="line"><span class="attribute">length</span>: <span class="string"> 5</span></span><br><span class="line"></span><br><span class="line"><span class="cpp">        <span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> </span><br><span class="line">before: H e l l o</span><br><span class="line">after:  o l l e H</span><br><span class="line"></span><br><span class="line">index             sum</span><br><span class="line"><span class="number">0</span>: H---&gt;o  <span class="number">0</span>--&gt;<span class="number">4</span>  <span class="number">4</span></span><br><span class="line"><span class="number">1</span>: e---&gt;l  <span class="number">1</span>--&gt;<span class="number">3</span>  <span class="number">4</span></span><br><span class="line"><span class="number">2</span>: l---&gt;l  <span class="number">2</span>--&gt;<span class="number">2</span>  <span class="number">4</span></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">分析字符串反转前后的规律可知:</span><br><span class="line">    两个反转字符串字符的下标之和为字符串长度-<span class="number">1.</span></span></span><br></pre></td></tr></table></figure></div><p class="readmore"><a href="/2016/06/22/深入浅出经典面试题之——反转字符串/">閱讀更多</a></p></div><div class="post"><h2 class="post-title"><a href="/2016/05/25/Binder-Android进程间的通信机制/">Binder:Android进程间的通信机制</a></h2><div class="post-meta">2016-05-25</div><div class="post-content"><p><img src="/image/android-logo.png" alt=""></p>
<p>在我们之前的文章<a href="/image/android-at-a-glance/">Android一瞥</a>中，我们介绍了Android的发展历程，解释了它的软件架构以及在Android平台开发应用需要注意什么。在本篇文章中，我将深入讨论<strong>Binder</strong>,复杂并且巨大的Android平台中的核心子系统。我将解释Binder中提供的不同组件,应用进程如何与系统进程通信，以及数据是如何被分享的。</p>
<p>由于智能手机的硬件性能的提升，被称为手中的PC，智能手机开始取代PC。伴随这种趋势，移动操作系统也开始支持多任务和使用多核CPU处理各种多媒体任务。大多数移动操作系统都是基于PC操作系统的。保留了现有PC操作系统的架构，内核稍作了修改以满足移动环境的要求，并添加一些优化的功能。Windows Phone基于微软Windows系统，iOS基于Mac的OS X，Google的Android系统基于Linux内核，三者都是最受欢迎的移动操作系统。<br></div><p class="readmore"><a href="/2016/05/25/Binder-Android进程间的通信机制/">閱讀更多</a></p></div><nav class="page-navigator"><span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/">下一頁</a></nav></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分類</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 標籤</i></div><div class="tagcloud"><a href="/tags/游记/" style="font-size: 15px;">游记</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/学习笔记/" style="font-size: 15px;">学习笔记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/CSS_Learn_Notes_2/">CSS学习笔记（二）——样式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/CSS_Learn_Notes_1/">CSS学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/27/理解RxJava(四)Reactive Android/">理解RxJava:(四)Reactive Android</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/26/理解RxJava(三)RxJava的优点/">理解RxJava:(三)RxJava的优点</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/23/理解RxJava(二)Operator，Operator/">理解RxJava:(二)Operator，Operator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/22/理解RxJava(一)基础知识/">理解RxJava:(一)基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/21/Android问题小结/">Android问题小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/Android如何从堆栈中还原ProGuard混淆后的代码/">Android:如何从堆栈中还原ProGuard混淆后的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/22/深入浅出经典面试题之——反转字符串/">深入浅出经典面试题之——反转字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/25/Binder-Android进程间的通信机制/">Binder:Android进程间的通信机制</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">JohnTsai.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>