<!DOCTYPE html><html lang="zh-Hans"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="No pain No gain"><title>理解RxJava:(四)Reactive Android | JohnTsai</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/5.0.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.2/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.1.1/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"><link rel="alternate" type="application/atom+xml" href="/atom.xml"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">理解RxJava:(四)Reactive Android</h1><a id="logo" href="/.">JohnTsai</a><p class="description">万物之中，希望最美，最美之物，永不凋零.</p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首頁</i></a><a href="/archives/"><i class="fa fa-archive"> 所有文章</i></a><a href="/about/"><i class="fa fa-user"> 關於</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">理解RxJava:(四)Reactive Android</h1><div class="post-meta">Jul 27, 2016<script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><div class="post-content"><p>在前三部分，我在通用层面介绍了RxJava的工作原理。但是作为一个Android开发者，如何在工作中使用它呢?下面是一些给Android开发者的RxJava的具体应用。</p>
<h2 id="RxAndroid"><a href="#RxAndroid" class="headerlink" title="RxAndroid"></a>RxAndroid</h2><p><a href="https://github.com/ReactiveX/RxAndroid" target="_blank" rel="external">RxAndroid</a>是RxJava在Android开发中的拓展。它包含能节省我们大量时间的特殊bindings。</p>
<p>首先，其中有<code>AndroidSchedulers</code>，它能提供专门为Android线程系统提供的schedulers。需要在UI线程运行代码?没问题——只需要使用<code>AndroidSchedulers.mainThread()</code>方法即可:</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">retrofitService</span><span class="class">.getImage</span>(<span class="tag">url</span>)</span><br><span class="line">    <span class="class">.subscribeOn</span>(<span class="tag">Schedulers</span><span class="class">.io</span>())</span><br><span class="line">    <span class="class">.observeOn</span>(<span class="tag">AndroidSchedulers</span><span class="class">.mainThread</span>())</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">bitmap</span> <span class="tag">-</span>&gt; <span class="tag">myImageView</span><span class="class">.setImageBitmap</span>(<span class="tag">bitmap</span>));</span><br></pre></td></tr></table></figure>
<p>如果你拿到的是<code>Handler</code>，可以通过<code>HandlerThreadScheduler</code>创建一个scheduler绑定在Handler上。</p>
<p>接下来介绍的是<code>AndroidObservable</code>，它能提供很多在Android生命周期中的特色功能。<code>bindActivity()</code>和<code>bindFragment()</code>方法能停止发出items，在<code>Activity</code>或<code>Fragment</code>结束的时候。另外会自动为订阅使用<code>AndroidSchedulers.mainThread()</code>。（因此你不需要在Activity或Fragment无效的时候来改变状态）。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">AndroidObservable</span><span class="class">.bindActivity</span>(<span class="tag">this</span>, <span class="tag">retrofitService</span><span class="class">.getImage</span>(<span class="tag">url</span>))</span><br><span class="line">    <span class="class">.subscribeOn</span>(<span class="tag">Schedulers</span><span class="class">.io</span>())</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">bitmap</span> <span class="tag">-</span>&gt; <span class="tag">myImageView</span><span class="class">.setImageBitmap</span>(<span class="tag">bitmap</span>));</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>我也喜欢<code>AndroidObservable.fromBroadcast()</code>，它让我们可以创建一个像<code>BroadcastReceiver</code>那样工作的<code>Observable</code>。以下是无论什么时候网络连接发生变化时通知的方法。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">IntentFilter <span class="built_in">filter</span> = <span class="keyword">new</span> IntentFilter(ConnectivityManager.CONNECTIVITY_ACTION);</span><br><span class="line">AndroidObservable.fromBroadcast(context, <span class="built_in">filter</span>)</span><br><span class="line">    .subscribe(intent -&gt; handleConnectivityChange(intent));</span><br></pre></td></tr></table></figure>
<p>最后介绍的是<code>ViewObservable</code>，它能为<code>Views</code>添加<code>bindings</code>。如果你想要得到<code>View</code>每次被点击的事件，可以通过<code>ViewObservable.clicks()</code>方法。也可以通过<code>ViewObservable.text()</code>方法来监测<code>TextView</code>的内容发生的任何变化。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">ViewObservable</span><span class="class">.clicks</span>(<span class="tag">mCardNameEditText</span>, <span class="tag">false</span>)</span><br><span class="line">    <span class="class">.subscribe</span>(<span class="tag">view</span> <span class="tag">-</span>&gt; <span class="tag">handleClick</span>(<span class="tag">view</span>));</span><br></pre></td></tr></table></figure>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p> 有一个知名并且支持RxJava的库：<a href="https://github.com/square/retrofit" target="_blank" rel="external">Retrofit</a>，它是Android开发中的非常出名的REST风格的网络库。通常，我们定义一个异步方法并添加<code>Callback</code>:</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GET</span>(<span class="string">"/user/&#123;id&#125;/photo"</span>)</span><br><span class="line">void <span class="function">getUserPhoto</span>(<span class="variable">@Path</span>(<span class="string">"id"</span>) int id, Callback&lt;Photo&gt; cb);</span><br></pre></td></tr></table></figure>
<p>用了RxJava，可以用<code>Observable</code>代替<code>Callback</code>作为返回值。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@GET</span>(<span class="string">"/user/&#123;id&#125;/photo"</span>)</span><br><span class="line">Observable&lt;Photo&gt; <span class="function">getUserPhoto</span>(<span class="variable">@Path</span>(<span class="string">"id"</span>) int id);</span><br></pre></td></tr></table></figure>
<p>现在可以对<code>Observable</code>做你想要的操作了，不仅可以获得数据，也能变换它。</p>
<p>Retrofit支持<code>Observable</code>，也使得合并多个REST请求变得容易。例如，假设我们有一个请求获得图片，另一个请求获得元数据(metadata)。我们可以把结果组合到一起:</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable.zip<span class="comment">(</span><br><span class="line">    service.getUserPhoto(id)</span>,</span><br><span class="line">    service.getPhotoMetadata<span class="comment">(id)</span>,</span><br><span class="line">    <span class="comment">(photo, metadata)</span> -&gt; createPhotoWithData<span class="comment">(photo, metadata)</span>)</span><br><span class="line">    .subscribe<span class="comment">(photoWithData -&gt; showPhoto(photoWithData)</span>);</span><br></pre></td></tr></table></figure>
<p>我在<a href="">第二部分</a>展示了相似的例子（使用<code>flatMap()</code>）。这便证明使用RxJava+Retrofit合并多个REST请求有多简单。</p>
<h2 id="u65E7_u7684_uFF0C_u8017_u65F6_u957F_u7684_u4EE3_u7801"><a href="#u65E7_u7684_uFF0C_u8017_u65F6_u957F_u7684_u4EE3_u7801" class="headerlink" title="旧的，耗时长的代码"></a>旧的，耗时长的代码</h2><p>Retrofit能返回<code>Observerables</code>这固然非常好，但是如果你用的其他的库不支持它呢？或者你想要将一些内部代码转换为<code>Observables</code>？总之，你如何将旧的代码和新的代码联系在一起，而不用重写所有代码?</p>
<p><code>Observable.just()</code>和<code>Observable.from()</code>大多数时候足以将以前的代码转换为<code>Observable</code>：</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">oldMethod</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;Object&gt; <span class="title">newMethod</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.just(oldMethod());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这在<code>oldMethod()</code>耗时少的情况下能正常工作，但是如果耗时长呢？因为调用<code>oldMethod()</code>，在它被传递到<code>Observable.just()</code>方法前就会阻塞了线程。</p>
<p>为了对付这个问题，以下是我一直使用的方法——使用<code>defer</code>方法将耗时长的部分包装起来。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private Object slowBlockingMethod() &#123; ... &#125;</span><br><span class="line"></span><br><span class="line">public Observable&lt;Object&gt; newMethod() &#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.defer<span class="function"><span class="params">(() -&gt; Observable.just(slowBlockingMethod()))</span>;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>现在，    直到你订阅<code>Observable</code>才会去调用<code>slowBlockMethod()</code>方法。</p>
<h2 id="u751F_u547D_u5468_u671F"><a href="#u751F_u547D_u5468_u671F" class="headerlink" title="生命周期"></a>生命周期</h2><p>我把最难的部分留在了最后。你是如何处理RxJava与Activity的生命周期的（配合使用的）？以下两个问题会多次出现：</p>
<ul>
<li><p>1.Activity的配置发生变化后继续订阅一个<code>Subscribtion</code></p>
<p>假设你用Retrofit做了一次REST请求，想要把请求结果展示在<code>ListView</code>上。如果用户旋转了屏幕怎么办？如果你想要继续相同的请求，但是如何做呢？</p>
</li>
<li><p>2.<code>Observables</code>持有<code>Context</code>引用会造成内存泄漏。</p>
<p> 这个问题是由于创建了一个以某种方式持有<code>Context</code>的<code>subscribtion</code>，特别是你和<code>Views</code>交互的时候容易出现。如果<code>Observable</code>没有准时完成，最后可能持有非常多的额外内存。</p>
</li>
</ul>
<p>不幸的是，两个问题都没有很好的解决办法。但是有一些能节约你时间的指导方针。</p>
<p>第一个问题能用一些RxJava内置的缓存机制解决，因此你可以取消订阅/再订阅同一个<code>Observable</code>，而不需要重复它之前的(准备)工作。特别的，<code>cache()</code>(或是<code>replay()</code>)方法将继续在（方法）之下的请求（即使你取消订阅）。这意味着Activity重新生成时,你能重新开始新的subscription。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;Photo&gt; request = service.getUserPhoto(id).cache();</span><br><span class="line">Subscription <span class="sub"><span class="keyword">sub</span> = request.subscribe(photo -&gt; handleUserPhoto(photo));</span></span><br><span class="line"></span><br><span class="line">// ...When the Activity is being recreated...</span><br><span class="line"><span class="sub"><span class="keyword">sub</span>.unsubscribe();</span></span><br><span class="line"></span><br><span class="line">// ...Once the Activity is recreated...</span><br><span class="line">request.subscribe(photo -&gt; handleUserPhoto(photo));</span><br></pre></td></tr></table></figure>
<p>注意我们在两种情况下，用的是同一个缓存的请求(<code>request</code>)，那种方式隐含的调用只会发生一次。存放请求的地方你自己决定，但是像所有的生命周期解决方案一样，它必须存放在生命周期之外的地方（一个保存的fragment，单例等等）。</p>
<p>第二问题可以通过根据生命周期正确的取消订阅来实现。通用的方法是用一个<code>CompositeSubscription</code>来持有所有的<code>Subscription</code>，然后在<code>onDestroy()</code>或<code>onDestroyView()</code>方法中取消所有的订阅。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> CompositeSubscription mCompositeSubscription</span><br><span class="line">    = <span class="keyword">new</span> CompositeSubscription();</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">void</span> <span class="title">doSomething</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCompositeSubscription.add(</span><br><span class="line">        AndroidObservable.bindActivity(<span class="keyword">this</span>, Observable.just(<span class="string">"Hello, World!"</span>))</span><br><span class="line">        .subscribe(s -&gt; System.out.println(s)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">    mCompositeSubscription.unsubscribe();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，你可以创建一个根<code>Activity</code>或<code>Fragment</code>，顺带添加一个<code>CompositeSubscription</code>，随后可以相应的取消订阅。</p>
<p>注意，只要你调用了<code>CompositeSubscription.unsubscribe()</code>，该对象(｀CompositeSubscription｀)就不能用了。因为它会自动取消订阅随后你添加的任何事物。如果你今后想要使用这种方法，你必须创建一个新的<code>CompositeSubscription</code>作为替代。</p>
<p>两个问题的解决方法都涉及到添加代码，我希望有一天能出现不需要写这些样板代码就能解决这些问题的天才。</p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://johntsai.work/2016/07/27/理解RxJava(四)Reactive Android/" data-id="cj0btyjeu0008kf1n3wmnlxag" class="article-share-link">分享至</a><div class="tags"><a href="/tags/Android/">Android</a><a href="/tags/Java/">Java</a><a href="/tags/RxJava/">RxJava</a></div><div class="post-nav"><a href="/2017/03/15/CSS_Learn_Notes_1/" class="pre">CSS学习笔记</a><a href="/2016/07/26/理解RxJava(三)RxJava的优点/" class="next">理解RxJava:(三)RxJava的优点</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分類</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 標籤</i></div><div class="tagcloud"><a href="/tags/游记/" style="font-size: 15px;">游记</a> <a href="/tags/Java/" style="font-size: 15px;">Java</a> <a href="/tags/RxJava/" style="font-size: 15px;">RxJava</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/算法/" style="font-size: 15px;">算法</a> <a href="/tags/学习笔记/" style="font-size: 15px;">学习笔记</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/CSS_Learn_Notes_2/">CSS学习笔记（二）——样式</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/03/15/CSS_Learn_Notes_1/">CSS学习笔记</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/27/理解RxJava(四)Reactive Android/">理解RxJava:(四)Reactive Android</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/26/理解RxJava(三)RxJava的优点/">理解RxJava:(三)RxJava的优点</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/23/理解RxJava(二)Operator，Operator/">理解RxJava:(二)Operator，Operator</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/22/理解RxJava(一)基础知识/">理解RxJava:(一)基础知识</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/21/Android问题小结/">Android问题小结</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/07/19/Android如何从堆栈中还原ProGuard混淆后的代码/">Android:如何从堆栈中还原ProGuard混淆后的代码</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/06/22/深入浅出经典面试题之——反转字符串/">深入浅出经典面试题之——反转字符串</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/05/25/Binder-Android进程间的通信机制/">Binder:Android进程间的通信机制</a></li></ul></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">JohnTsai.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>